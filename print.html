<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js iota">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chrysalis Documentation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="./theme/css/custom.css">
        
        <link rel="stylesheet" href="./theme/css/custom/header.css">
        

        

        <script src='/public/build/bundle.js'></script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "iota";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('iota')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/welcome.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="introduction/what_is_chrysalis.html"><strong aria-hidden="true">2.</strong> What is Chrysalis?</a></li><li class="chapter-item expanded "><a href="introduction/path_to_chrysalis.html"><strong aria-hidden="true">3.</strong> Path to Chrysalis</a></li><li class="chapter-item expanded "><a href="firefly/index.html"><strong aria-hidden="true">4.</strong> Firefly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="firefly/verify_download.html"><strong aria-hidden="true">4.1.</strong> Verify Download</a></li></ol></li><li class="chapter-item expanded "><a href="node-software/node-software.html"><strong aria-hidden="true">5.</strong> Node Software</a></li><li class="chapter-item expanded "><a href="libraries/overview.html"><strong aria-hidden="true">6.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/client.html"><strong aria-hidden="true">6.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="libraries/wallet.html"><strong aria-hidden="true">6.2.</strong> Wallet Lib</a></li></ol></li><li class="chapter-item expanded "><a href="guides/index.html"><strong aria-hidden="true">7.</strong> Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/dev_guide.html"><strong aria-hidden="true">7.1.</strong> Developer</a></li><li class="chapter-item expanded "><a href="guides/exchange_guide.html"><strong aria-hidden="true">7.2.</strong> Exchange</a></li><li class="chapter-item expanded "><a href="guides/token_guide.html"><strong aria-hidden="true">7.3.</strong> Token Migration</a></li><li class="chapter-item expanded "><a href="guides/migration-mechanism.html"><strong aria-hidden="true">7.4.</strong> Migration Mechanism</a></li><li class="chapter-item expanded "><a href="guides/hub_guide.html"><strong aria-hidden="true">7.5.</strong> Hub Migration</a></li><li class="chapter-item expanded "><a href="guides/backup_security.html"><strong aria-hidden="true">7.6.</strong> Backup and Security</a></li><li class="chapter-item expanded "><a href="guides/snapshot_validation_bootstrapping.html"><strong aria-hidden="true">7.7.</strong> Chrysalis Snapshot Validation</a></li></ol></li><li class="chapter-item expanded "><a href="testnet.html"><strong aria-hidden="true">8.</strong> Testnet</a></li><li class="chapter-item expanded "><a href="rfc.html"><strong aria-hidden="true">9.</strong> Protocol RFCs</a></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">10.</strong> Resources</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">11.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div class="logo-wrapper">
    <svg id="logo" width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M40.4006 12.8961C41.8945 12.8961 43.1056 11.6882 43.1056 10.1981C43.1056 8.70796 41.8945 7.5 40.4006 7.5C38.9066 7.5 37.6956 8.70796 37.6956 10.1981C37.6956 11.6882 38.9066 12.8961 40.4006 12.8961Z" fill="#485776"></path><path d="M43.4438 51.0067C44.9377 51.0067 46.1488 49.7987 46.1488 48.3086C46.1488 46.8186 44.9377 45.6106 43.4438 45.6106C41.9498 45.6106 40.7388 46.8186 40.7388 48.3086C40.7388 49.7987 41.9498 51.0067 43.4438 51.0067Z" fill="#485776"></path><path d="M41.1739 19.6414C42.4277 19.6414 43.4441 18.6276 43.4441 17.377C43.4441 16.1264 42.4277 15.1125 41.1739 15.1125C39.92 15.1125 38.9036 16.1264 38.9036 17.377C38.9036 18.6276 39.92 19.6414 41.1739 19.6414Z" fill="#485776"></path><path d="M47.2122 20.5084C48.466 20.5084 49.4825 19.4945 49.4825 18.2439C49.4825 16.9933 48.466 15.9795 47.2122 15.9795C45.9583 15.9795 44.9419 16.9933 44.9419 18.2439C44.9419 19.4945 45.9583 20.5084 47.2122 20.5084Z" fill="#485776"></path><path d="M40.4012 25.3746C41.4683 25.3746 42.3333 24.5118 42.3333 23.4475C42.3333 22.3831 41.4683 21.5203 40.4012 21.5203C39.3341 21.5203 38.469 22.3831 38.469 23.4475C38.469 24.5118 39.3341 25.3746 40.4012 25.3746Z" fill="#485776"></path><path d="M46.4385 26.1942C47.5056 26.1942 48.3707 25.3314 48.3707 24.267C48.3707 23.2027 47.5056 22.3398 46.4385 22.3398C45.3714 22.3398 44.5063 23.2027 44.5063 24.267C44.5063 25.3314 45.3714 26.1942 46.4385 26.1942Z" fill="#485776"></path><path d="M51.2693 28.0729C52.3364 28.0729 53.2015 27.21 53.2015 26.1457C53.2015 25.0813 52.3364 24.2185 51.2693 24.2185C50.2022 24.2185 49.3372 25.0813 49.3372 26.1457C49.3372 27.21 50.2022 28.0729 51.2693 28.0729Z" fill="#485776"></path><path d="M44.6516 30.8191C45.5853 30.8191 46.3422 30.0641 46.3422 29.1328C46.3422 28.2015 45.5853 27.4465 44.6516 27.4465C43.7179 27.4465 42.9609 28.2015 42.9609 29.1328C42.9609 30.0641 43.7179 30.8191 44.6516 30.8191Z" fill="#485776"></path><path d="M38.6137 29.9995C39.5475 29.9995 40.3044 29.2446 40.3044 28.3132C40.3044 27.3819 39.5475 26.627 38.6137 26.627C37.68 26.627 36.9231 27.3819 36.9231 28.3132C36.9231 29.2446 37.68 29.9995 38.6137 29.9995Z" fill="#485776"></path><path d="M49.5302 32.6978C50.464 32.6978 51.2209 31.9428 51.2209 31.0115C51.2209 30.0802 50.464 29.3252 49.5302 29.3252C48.5965 29.3252 47.8396 30.0802 47.8396 31.0115C47.8396 31.9428 48.5965 32.6978 49.5302 32.6978Z" fill="#485776"></path><path d="M42.2367 34.3358C43.037 34.3358 43.6858 33.6887 43.6858 32.8905C43.6858 32.0922 43.037 31.4451 42.2367 31.4451C41.4364 31.4451 40.7876 32.0922 40.7876 32.8905C40.7876 33.6887 41.4364 34.3358 42.2367 34.3358Z" fill="#485776"></path><path d="M47.1154 36.1669C47.9157 36.1669 48.5645 35.5198 48.5645 34.7215C48.5645 33.9232 47.9157 33.2761 47.1154 33.2761C46.3151 33.2761 45.6663 33.9232 45.6663 34.7215C45.6663 35.5198 46.3151 36.1669 47.1154 36.1669Z" fill="#485776"></path><path d="M36.2465 33.4684C37.0468 33.4684 37.6956 32.8213 37.6956 32.023C37.6956 31.2248 37.0468 30.5776 36.2465 30.5776C35.4462 30.5776 34.7974 31.2248 34.7974 32.023C34.7974 32.8213 35.4462 33.4684 36.2465 33.4684Z" fill="#485776"></path><path d="M39.5797 36.6971C40.2466 36.6971 40.7873 36.1578 40.7873 35.4926C40.7873 34.8274 40.2466 34.2881 39.5797 34.2881C38.9127 34.2881 38.3721 34.8274 38.3721 35.4926C38.3721 36.1578 38.9127 36.6971 39.5797 36.6971Z" fill="#485776"></path><path d="M41.6567 40.0213C42.2436 40.0213 42.7194 39.5467 42.7194 38.9613C42.7194 38.3759 42.2436 37.9014 41.6567 37.9014C41.0698 37.9014 40.594 38.3759 40.594 38.9613C40.594 39.5467 41.0698 40.0213 41.6567 40.0213Z" fill="#485776"></path><path d="M39.0965 40.6961C39.5767 40.6961 39.966 40.3079 39.966 39.8289C39.966 39.3499 39.5767 38.9617 39.0965 38.9617C38.6163 38.9617 38.2271 39.3499 38.2271 39.8289C38.2271 40.3079 38.6163 40.6961 39.0965 40.6961Z" fill="#485776"></path><path d="M36.8261 38.1904C37.413 38.1904 37.8888 37.7159 37.8888 37.1305C37.8888 36.5451 37.413 36.0706 36.8261 36.0706C36.2392 36.0706 35.7634 36.5451 35.7634 37.1305C35.7634 37.7159 36.2392 38.1904 36.8261 38.1904Z" fill="#485776"></path><path d="M33.5421 35.878C34.209 35.878 34.7497 35.3387 34.7497 34.6735C34.7497 34.0083 34.209 33.469 33.5421 33.469C32.8751 33.469 32.3345 34.0083 32.3345 34.6735C32.3345 35.3387 32.8751 35.878 33.5421 35.878Z" fill="#485776"></path><path d="M33.4932 26.8196C34.1602 26.8196 34.7008 26.2804 34.7008 25.6151C34.7008 24.9499 34.1602 24.4106 33.4932 24.4106C32.8263 24.4106 32.2856 24.9499 32.2856 25.6151C32.2856 26.2804 32.8263 26.8196 33.4932 26.8196Z" fill="#485776"></path><path d="M34.0246 22.5799C34.6115 22.5799 35.0873 22.1053 35.0873 21.5199C35.0873 20.9345 34.6115 20.46 34.0246 20.46C33.4377 20.46 32.9619 20.9345 32.9619 21.5199C32.9619 22.1053 33.4377 22.5799 34.0246 22.5799Z" fill="#485776"></path><path d="M35.1842 19.1109C35.6644 19.1109 36.0537 18.7227 36.0537 18.2437C36.0537 17.7647 35.6644 17.3765 35.1842 17.3765C34.704 17.3765 34.3147 17.7647 34.3147 18.2437C34.3147 18.7227 34.704 19.1109 35.1842 19.1109Z" fill="#485776"></path><path d="M33.1552 17.4732C33.7421 17.4732 34.2179 16.9986 34.2179 16.4132C34.2179 15.8278 33.7421 15.3533 33.1552 15.3533C32.5683 15.3533 32.0925 15.8278 32.0925 16.4132C32.0925 16.9986 32.5683 17.4732 33.1552 17.4732Z" fill="#485776"></path><path d="M44.4102 38.5274C45.0772 38.5274 45.6178 37.9881 45.6178 37.3229C45.6178 36.6577 45.0772 36.1184 44.4102 36.1184C43.7433 36.1184 43.2026 36.6577 43.2026 37.3229C43.2026 37.9881 43.7433 38.5274 44.4102 38.5274Z" fill="#485776"></path><path d="M30.4019 16.076C31.0689 16.076 31.6095 15.5367 31.6095 14.8715C31.6095 14.2063 31.0689 13.667 30.4019 13.667C29.735 13.667 29.1943 14.2063 29.1943 14.8715C29.1943 15.5367 29.735 16.076 30.4019 16.076Z" fill="#485776"></path><path d="M31.2232 21.1832C31.8902 21.1832 32.4308 20.6439 32.4308 19.9787C32.4308 19.3134 31.8902 18.7742 31.2232 18.7742C30.5563 18.7742 30.0156 19.3134 30.0156 19.9787C30.0156 20.6439 30.5563 21.1832 31.2232 21.1832Z" fill="#485776"></path><path d="M29.871 26.049C30.6713 26.049 31.3201 25.4019 31.3201 24.6036C31.3201 23.8053 30.6713 23.1582 29.871 23.1582C29.0707 23.1582 28.4219 23.8053 28.4219 24.6036C28.4219 25.4019 29.0707 26.049 29.871 26.049Z" fill="#485776"></path><path d="M25.4748 26.0488C26.4085 26.0488 27.1655 25.2939 27.1655 24.3626C27.1655 23.4312 26.4085 22.6763 25.4748 22.6763C24.5411 22.6763 23.7842 23.4312 23.7842 24.3626C23.7842 25.2939 24.5411 26.0488 25.4748 26.0488Z" fill="#485776"></path><path d="M20.355 27.2057C21.4221 27.2057 22.2872 26.3429 22.2872 25.2785C22.2872 24.2141 21.4221 23.3513 20.355 23.3513C19.2879 23.3513 18.4229 24.2141 18.4229 25.2785C18.4229 26.3429 19.2879 27.2057 20.355 27.2057Z" fill="#485776"></path><path d="M14.7517 29.9522C16.0056 29.9522 17.022 28.9384 17.022 27.6878C17.022 26.4372 16.0056 25.4233 14.7517 25.4233C13.4979 25.4233 12.4814 26.4372 12.4814 27.6878C12.4814 28.9384 13.4979 29.9522 14.7517 29.9522Z" fill="#485776"></path><path d="M8.95503 34.577C10.449 34.577 11.6601 33.3691 11.6601 31.879C11.6601 30.3889 10.449 29.1809 8.95503 29.1809C7.46109 29.1809 6.25 30.3889 6.25 31.879C6.25 33.3691 7.46109 34.577 8.95503 34.577Z" fill="#485776"></path><path d="M12.4817 24.3148C13.7356 24.3148 14.752 23.3009 14.752 22.0503C14.752 20.7997 13.7356 19.7859 12.4817 19.7859C11.2279 19.7859 10.2114 20.7997 10.2114 22.0503C10.2114 23.3009 11.2279 24.3148 12.4817 24.3148Z" fill="#485776"></path><path d="M18.0843 21.5682C19.1514 21.5682 20.0164 20.7054 20.0164 19.6411C20.0164 18.5767 19.1514 17.7139 18.0843 17.7139C17.0172 17.7139 16.1521 18.5767 16.1521 19.6411C16.1521 20.7054 17.0172 21.5682 18.0843 21.5682Z" fill="#485776"></path><path d="M17.263 16.4611C18.3301 16.4611 19.1951 15.5982 19.1951 14.5339C19.1951 13.4695 18.3301 12.6067 17.263 12.6067C16.1959 12.6067 15.3308 13.4695 15.3308 14.5339C15.3308 15.5982 16.1959 16.4611 17.263 16.4611Z" fill="#485776"></path><path d="M22.3835 15.3049C23.3172 15.3049 24.0742 14.55 24.0742 13.6187C24.0742 12.6873 23.3172 11.9324 22.3835 11.9324C21.4498 11.9324 20.6929 12.6873 20.6929 13.6187C20.6929 14.55 21.4498 15.3049 22.3835 15.3049Z" fill="#485776"></path><path d="M26.779 15.3051C27.5793 15.3051 28.2281 14.658 28.2281 13.8597C28.2281 13.0614 27.5793 12.4143 26.779 12.4143C25.9786 12.4143 25.3298 13.0614 25.3298 13.8597C25.3298 14.658 25.9786 15.3051 26.779 15.3051Z" fill="#485776"></path><path d="M27.6003 20.4118C28.4006 20.4118 29.0494 19.7646 29.0494 18.9664C29.0494 18.1681 28.4006 17.521 27.6003 17.521C26.7999 17.521 26.1511 18.1681 26.1511 18.9664C26.1511 19.7646 26.7999 20.4118 27.6003 20.4118Z" fill="#485776"></path><path d="M23.2048 20.4605C24.1385 20.4605 24.8955 19.7055 24.8955 18.7742C24.8955 17.8429 24.1385 17.0879 23.2048 17.0879C22.2711 17.0879 21.5142 17.8429 21.5142 18.7742C21.5142 19.7055 22.2711 20.4605 23.2048 20.4605Z" fill="#485776"></path><path d="M18.4225 33.276C18.9026 33.276 19.2919 32.8877 19.2919 32.4087C19.2919 31.9298 18.9026 31.5415 18.4225 31.5415C17.9423 31.5415 17.553 31.9298 17.553 32.4087C17.553 32.8877 17.9423 33.276 18.4225 33.276Z" fill="#485776"></path><path d="M21.9006 32.8428C22.4875 32.8428 22.9633 32.3682 22.9633 31.7828C22.9633 31.1975 22.4875 30.7229 21.9006 30.7229C21.3137 30.7229 20.8379 31.1975 20.8379 31.7828C20.8379 32.3682 21.3137 32.8428 21.9006 32.8428Z" fill="#485776"></path><path d="M25.7161 31.3975C26.3831 31.3975 26.9237 30.8582 26.9237 30.193C26.9237 29.5278 26.3831 28.9885 25.7161 28.9885C25.0492 28.9885 24.5085 29.5278 24.5085 30.193C24.5085 30.8582 25.0492 31.3975 25.7161 31.3975Z" fill="#485776"></path><path d="M26.6342 35.2516C27.4345 35.2516 28.0833 34.6045 28.0833 33.8062C28.0833 33.008 27.4345 32.3608 26.6342 32.3608C25.8339 32.3608 25.1851 33.008 25.1851 33.8062C25.1851 34.6045 25.8339 35.2516 26.6342 35.2516Z" fill="#485776"></path><path d="M21.9974 36.1666C22.6643 36.1666 23.205 35.6273 23.205 34.9621C23.205 34.2968 22.6643 33.7576 21.9974 33.7576C21.3305 33.7576 20.7898 34.2968 20.7898 34.9621C20.7898 35.6273 21.3305 36.1666 21.9974 36.1666Z" fill="#485776"></path><path d="M17.8911 36.1184C18.478 36.1184 18.9538 35.6439 18.9538 35.0585C18.9538 34.4731 18.478 33.9985 17.8911 33.9985C17.3042 33.9985 16.8284 34.4731 16.8284 35.0585C16.8284 35.6439 17.3042 36.1184 17.8911 36.1184Z" fill="#485776"></path><path d="M17.939 39.4432C18.606 39.4432 19.1467 38.9039 19.1467 38.2387C19.1467 37.5734 18.606 37.0342 17.939 37.0342C17.2721 37.0342 16.7314 37.5734 16.7314 38.2387C16.7314 38.9039 17.2721 39.4432 17.939 39.4432Z" fill="#485776"></path><path d="M22.8664 40.0692C23.6667 40.0692 24.3155 39.4221 24.3155 38.6239C24.3155 37.8256 23.6667 37.1785 22.8664 37.1785C22.066 37.1785 21.4172 37.8256 21.4172 38.6239C21.4172 39.4221 22.066 40.0692 22.8664 40.0692Z" fill="#485776"></path><path d="M28.6152 39.4431C29.5489 39.4431 30.3058 38.6882 30.3058 37.7568C30.3058 36.8255 29.5489 36.0706 28.6152 36.0706C27.6815 36.0706 26.9246 36.8255 26.9246 37.7568C26.9246 38.6882 27.6815 39.4431 28.6152 39.4431Z" fill="#485776"></path><path d="M31.9956 43.6344C33.0627 43.6344 33.9278 42.7716 33.9278 41.7072C33.9278 40.6429 33.0627 39.78 31.9956 39.78C30.9285 39.78 30.0635 40.6429 30.0635 41.7072C30.0635 42.7716 30.9285 43.6344 31.9956 43.6344Z" fill="#485776"></path><path d="M24.8955 44.2129C25.8292 44.2129 26.5861 43.4579 26.5861 42.5266C26.5861 41.5953 25.8292 40.8403 24.8955 40.8403C23.9618 40.8403 23.2048 41.5953 23.2048 42.5266C23.2048 43.4579 23.9618 44.2129 24.8955 44.2129Z" fill="#485776"></path><path d="M20.886 47.4888C21.8197 47.4888 22.5766 46.7338 22.5766 45.8025C22.5766 44.8712 21.8197 44.1162 20.886 44.1162C19.9522 44.1162 19.1953 44.8712 19.1953 45.8025C19.1953 46.7338 19.9522 47.4888 20.886 47.4888Z" fill="#485776"></path><path d="M24.2188 51.7289C25.2859 51.7289 26.1509 50.8661 26.1509 49.8017C26.1509 48.7373 25.2859 47.8745 24.2188 47.8745C23.1517 47.8745 22.2866 48.7373 22.2866 49.8017C22.2866 50.8661 23.1517 51.7289 24.2188 51.7289Z" fill="#485776"></path><path d="M33.107 52.5001C34.3608 52.5001 35.3773 51.4863 35.3773 50.2356C35.3773 48.985 34.3608 47.9712 33.107 47.9712C31.8531 47.9712 30.8367 48.985 30.8367 50.2356C30.8367 51.4863 31.8531 52.5001 33.107 52.5001Z" fill="#485776"></path><path d="M28.2283 48.4525C29.2954 48.4525 30.1605 47.5897 30.1605 46.5253C30.1605 45.461 29.2954 44.5981 28.2283 44.5981C27.1612 44.5981 26.2961 45.461 26.2961 46.5253C26.2961 47.5897 27.1612 48.4525 28.2283 48.4525Z" fill="#485776"></path><path d="M36.8267 47.6822C38.0805 47.6822 39.097 46.6684 39.097 45.4178C39.097 44.1671 38.0805 43.1533 36.8267 43.1533C35.5728 43.1533 34.5564 44.1671 34.5564 45.4178C34.5564 46.6684 35.5728 47.6822 36.8267 47.6822Z" fill="#485776"></path><path d="M18.8571 43.3458C19.6574 43.3458 20.3062 42.6987 20.3062 41.9005C20.3062 41.1022 19.6574 40.4551 18.8571 40.4551C18.0568 40.4551 17.408 41.1022 17.408 41.9005C17.408 42.6987 18.0568 43.3458 18.8571 43.3458Z" fill="#485776"></path></svg>
</div>
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="iota">IOTA (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Chrysalis Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/iotaledger/chrysalis-docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>This page outlines the fundamental changes to the IOTA protocol which will be deployed in 2021 in a release called Chrysalis.</p>
<p><img src="introduction/./assets/01_butterfly.png" alt="" /></p>
<h1 id="what-is-chrysalis"><a class="header" href="#what-is-chrysalis">What is Chrysalis</a></h1>
<p>The objective of the IOTA Foundation is to optimize the IOTA mainnet before Coordicide and to offer an enterprise-ready solution for our ecosystem. This will be achieved by an intermediate update called <code>Chrysalis</code>. This post explains what the Chrysalis upgrade entails.</p>
<p><img src="introduction/./assets/what_is_chrysalis/00.gif" alt="" /></p>
<p>A chrysalis is “the form a caterpillar takes before it emerges from its cocoon as a fully-formed moth or butterfly”. In the context of IOTA, Chrysalis is the mainnet’s intermediate stage before Coordicide is complete. The main purpose of Chrysalis is to improve the usability of the current IOTA mainnet, for users and developers alike.</p>
<p><img src="introduction/./assets/02_path_to.png" alt="" /></p>
<p>Why is this process of adopting major protocol improvements relatively unique to IOTA among permissionless DLTs? The simple answer is the absence of miners. In most permissionless DLTs, the miners’ economic incentives differ from those of regular network users. Changes to throughput and network latencies can disrupt the fee market the miners rely on. This in turn makes them likely to object to network upgrades as it affects their bottom line.</p>
<p>In IOTA, validators and users are one and the same. There is no conflict of interests between parties with different motivations, meaning there is a much smoother path to network improvements. This is why we are able to incrementally and smoothly upgrade the network before Coordicide.</p>
<p>What are the specific Chrysalis upgrades?</p>
<h2 id="white-flag-approach"><a class="header" href="#white-flag-approach">White-flag approach</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/01.png" alt="" />
<a href="https://iota.cafe/t/conflict-white-flag-mitigate-conflict-spamming-by-ignoring-conflicts/233">The White-flag approach</a> which is used for calculating balances. It is a simpler, conflict-ignoring approach that improves the speed and efficiency of tip selection, eliminates many network attacks, and significantly reduces the need for reattachments.</p>
<h2 id="new-milestone-selection-algorithm"><a class="header" href="#new-milestone-selection-algorithm">New milestone selection algorithm</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/02.png" alt="" />
<a href="https://iota.cafe/t/coordinator-improvements/310">A new milestone selection algorithm for the coordinator</a>, that focuses on allowing the network to support much more confirmed transactions per second (CTPS) than before with higher computational efficiency.</p>
<h2 id="urts-tip-selection"><a class="header" href="#urts-tip-selection">URTS tip selection</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/03.png" alt="" />
A new <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0008-uniform-random-tip-selection/0008-uniform-random-tip-selection.md">Uniform random tip selection</a> in node software. It is significantly faster and more efficient than the previous tip selection algorithm.</p>
<h2 id="ed25519-signature-scheme"><a class="header" href="#ed25519-signature-scheme">Ed25519 signature scheme</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/04.png" alt="" />
<a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">The Ed25519 signature scheme</a> has been added to the network, replacing the current Winternitz one time signature scheme (W-OTS) signature scheme. Using an EdDSA signature scheme allows the protocol and clients using the protocol to run more efficiently on established hardware. Unlike W-OTS, the scheme also allows for the re-use of private keys, and, with that, introduces reusable addresses to the protocol. This change also dramatically reduces the transaction size, saving network bandwidth and processing time.</p>
<h2 id="atomic-transactions"><a class="header" href="#atomic-transactions">Atomic transactions</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/05.png" alt="" />
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Atomic transactions</a> that move the protocol from the current, complicated, bundle construct and use simpler atomic transactions instead. This results in much simpler development and more adaptable and maintainable code of the core software. In addition, atomic transactions reduce network overhead, reduce transaction validation and signature verification load, and improve spam protection and congestion control.</p>
<h2 id="switch-to-utxo-model"><a class="header" href="#switch-to-utxo-model">Switch to UTXO Model</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/06.png" alt="" />
<a href="https://iota.cafe/t/switching-to-utxo-model-for-balances-colored-coins-easier-conflict-resolution/229">A switch to the UTXO model</a> from the current account model. Every coin on an address becomes uniquely identifiable and every spend names the exact coins that it wants to move. This allows for faster and more exact conflict handling and improves resilience and security of the protocol. In addition, switching to UTXO makes other functionalities, such as colored tokens, on the protocol possible in the future.</p>
<h2 id="internal-binary-representation"><a class="header" href="#internal-binary-representation">Internal Binary Representation</a></h2>
<p><img src="introduction/./assets/what_is_chrysalis/07.png" alt="" />
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">A switch to an internal binary representation of the trinary transaction</a>. This allows us to work on binary data for validation, IO, and other processing without the current reliance on binary-ternary conversions as in the pre-Chrysalis software node software. The switch to binary transactions further reduces the transaction size, saving network bandwidth and processing time.</p>
<h2 id="new-node-api-and-client-libraries"><a class="header" href="#new-node-api-and-client-libraries">New node API and client libraries</a></h2>
<p>With Chrysalis, we wanted to offer a more standard API on both the node and client library level. Node implementations provide a completely redesigned <a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">RESTful</a> and <a href="https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/luca-moser/protocol-rfcs/rfc/node-event-api/text/0033-node-event-api/0033-node-event-api.yml">eventful</a> API implementations.</p>
<p>Our <a href="introduction/../libraries/overview.html">client libraries</a> provide high level abstractions that allow developers to build solutions that are easier to develop and cheaper to maintain.</p>
<h1 id="path-to-chrysalis"><a class="header" href="#path-to-chrysalis">Path to Chrysalis</a></h1>
<p>One of the IOTA Foundation’s primary roles is defining and delivering on a development roadmap that aligns with the Foundation's strategy to reach production-readiness and adoption.</p>
<p>The IOTA mainnet has been operational since 2016 and the overall engineering strategy evolved significantly based on industry demand and feedback.</p>
<p>Progress in Coordicide research has resulted in identifying many concepts that could already be implemented on the current IOTA mainnet and provides significant value to users of the protocol before Coordicide. This led to the formalization of our engineering strategy around Chrysalis: a series of upgrades to the protocol that achieves production-readiness before Coordicide.</p>
<p>The benefit of this approach is that many of the protocol properties will remain the same, or almost the same, for Coordicide. That, together with a better set of developer tools, will make the transition to Coordicide much simpler.</p>
<p>The intended outcomes for Chrysalis are:</p>
<ul>
<li><strong>Simpler transition to Coordicide</strong> - With Coordicide making significant progress, we want to ensure that all developers and companies that build and deploy on Chrysalis will have as smooth a transition to Coordicide as possible.</li>
<li><strong>Substantial performance improvements</strong> - With the changes introduced by Chrysalis, we will see a substantial improvement in the scalability and reliability of the IOTA Mainnet.</li>
<li><strong>Improved developer and user experience</strong> - The new protocol features, new libraries, and the new wallet will make IOTA one of the best platforms to build on, removing the friction which developers experience today while allowing solutions built on top of the protocol to provide better user experience.</li>
<li><strong>Accelerated adoption</strong> - Chrysalis will make IOTA production-ready; becoming a stable protocol, with a reliable set of developer tools and frameworks that will enable startups, corporations, and governments to develop and launch products powered by IOTA.</li>
</ul>
<h2 id="the-stages-to-chrysalis"><a class="header" href="#the-stages-to-chrysalis">The stages to Chrysalis</a></h2>
<p><img src="introduction//Users/charlesthompson/chrysalis-docs/docs/introduction/assets/path_to_chrysalis/01.png" alt="" /></p>
<p>The Chrysalis upgrade is a complex undertaking. We are coordinating a number of distinct products to ensure a smooth transition for IOTA’s current users and partners. In addition to the core node software, we also need to update our wallet software, our libraries, and the entire infrastructure.</p>
<p>Another important requirement is the ease of transition to the future Coordicide network. By carefully planning the breaking changes introduced along the way, and providing support in our developer tools, we will ensure that our growing ecosystem of developers, startups, and corporations can reliably develop and launch new innovative products on IOTA.</p>
<p>The plan for implementing Chrysalis is divided into two phases.</p>
<p><strong>The first phase</strong> consisted of improved tip selection (URTS), milestone selection, and White flag. These were implemented in the node software gradually. This phase required an upgrade of all nodes, including the coordinator node, and did not require a snapshot.</p>
<p>The first phase of Chrysalis resulted in:</p>
<ul>
<li>Transaction confirmation times of around 10 seconds</li>
<li>Transactions rarely needing reattachment</li>
<li>A substantial TPS increase</li>
<li>Performance and reliability improvements for nodes</li>
</ul>
<p><strong>The second phase</strong> of Chrysalis consists of adopting and/or implementing UTXO, atomic transactions, reusable addresses (Ed25519), a transition to a binary transaction layout, and a new set of client libraries and developer tools. These represent significant changes to the core protocol and the way transactions are structured. Once everything has been tested, validated, and audited, the Foundation will deploy a new Chrysalis network. The upgrade will consist of an extended period when the current, legacy network remains operational. This allows users, exchanges, and partners to migrate to the Chrysalis network at will. The migration is not time constrained.</p>
<p>The second phase of Chrysalis consists of:</p>
<ul>
<li>Reusable addresses and support for more standard cryptography (EdDSA), making efficient hardware support for all major architectures possible</li>
<li>A simplified transaction layout and a reduction in transaction size, further increasing performance and efficiency</li>
<li>Significant improvements to the usability and reliability of IOTA</li>
<li>A switch to a UTXO based model from the current account model</li>
</ul>
<p>The introduction of reusable addresses is an important change for token holders. This will vastly improve IOTA’s usability and make integration into new exchanges, wallets, and payment systems much simpler. A new wallet, called Firefly, will be released with Chrysalis. This wallet will allow token holders to transition from the current WOTS address scheme to the new EdDSA scheme.</p>
<p>Our goal is to make this transition as seamless as possible for everyone in the IOTA ecosystem. This includes a variety of improvements and updates to our libraries and software, as well as training and educational sessions for our partners.</p>
<h3 id="from-plan-to-action"><a class="header" href="#from-plan-to-action">From plan to action</a></h3>
<p>With Chrysalis, we had to make decisions on how to best implement all the upcoming changes, ensuring a correct and timely implementation. What follows is an overview of the various components we are working on to successfully implement this update.</p>
<h3 id="specification-and-standardization"><a class="header" href="#specification-and-standardization">Specification and standardization</a></h3>
<p>Specifications are a major part of our new development process. All our new software projects (Node software, Wallet, Identity, Access, Streams, etc.) are based on vetted specifications. Specifications make it possible for external parties to follow a project’s intended functionality, for example for audit purposes, or develop their own implementations in different languages.</p>
<p>The Chrysalis changes are specified in the form of RFCs. You can find all the RFCs in the <a href="https://github.com/iotaledger/protocol-rfcs">protocol-rfcs repository</a>. The list of Chrysalis RFCs includes:</p>
<ul>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/rfc-urts-tip-sel/text/0008-weighted-uniform-random-tip-selection/0008-weighted-uniform-random-tip-selection.md">Improved tip selection (URTS)</a></li>
<li><a href="https://github.com/iotaledger/protocol-rfcs/blob/milestone-merkle-validation-chrysalis-pt-2/text/0012-milestone-merkle-validation/0012-milestone-merkle-validation.md">Milestone selection</a></li>
<li><a href="https://github.com/thibault-martinez/protocol-rfcs/blob/rfc-white-flag/text/0005-white-flag/0005-white-flag.md">White flag</a></li>
<li><a href="https://github.com/hmoog/protocol-rfcs/blob/master/text/0011-utxo-model/0011-utxo-model.md">UTXO</a></li>
<li><a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">Ed25519 Signature Scheme</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/ed25519/text/0009-ed25519-signature-scheme/0009-ed25519-signature-scheme.md">Reusable addresses (Ed25519)</a></li>
<li><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Message object</a></li>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Binary transaction layout</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/message-pow/text/0024-message-pow/0024-message-pow.md">Message proof of work</a></li>
<li><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/dust/text/0032-dust-protection/0032-dust-protection.md">Dust protection</a></li>
<li><a href="https://github.com/luca-moser/protocol-rfcs/blob/local-snapshot-file-format/text/0000-local-snapshot-file-format/0000-local-snapshot-file-format.md">New local snapshot file format</a></li>
<li><a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">Bech32 address format</a></li>
<li><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">RESTful node API</a></li>
<li><a href="https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/luca-moser/protocol-rfcs/rfc/node-event-api/text/0033-node-event-api/0033-node-event-api.yml">Eventful node API</a></li>
</ul>
<h3 id="wallet-support"><a class="header" href="#wallet-support">Wallet support</a></h3>
<p>The Trinity wallet is a popular IOTA wallet. With Chrysalis, we will release a new wallet implementation, <a href="https://blog.iota.org/firefly-iota-next-generation-wallet-26bdd4d01510/">Firefly</a>. The team has been working on a complete reevaluation of the wallet architecture, with a completely redesigned user experience. At its core will be a <a href="introduction/../libraries/wallet.html">new wallet library</a> written in Rust. The wallet library is designed to allow other developers to easily implement IOTA wallets within their applications. Another new Rust library utilized by Firefly is Stronghold; Stronghold enables ultra-secure secret handling and storage.</p>
<h3 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h3>
<p>Currently, the IOTA Foundation supports two public Networks: Mainnet and Devnet (Devnet is for PoCs and application tests). Both networks provide public endpoints for users and partners. You can read more about the networks and how you can participate in our <a href="https://docs.iota.org/docs/getting-started/1.1/networks/overview">documentation</a>.</p>
<p>While the current Mainnet will be replaced by a new network, it will remain operational for an extended period of time. For the purposes of non-time-constrained transition of projects deployed on Devnet, the Devnet will only be upgraded after the Chrysalis release.</p>
<p>The Chrysalis testnet has been operational since December and we encourage everyone to use it to build and test their solutions before the official launch of Chrysalis.</p>
<h3 id="chrysalis-testnet"><a class="header" href="#chrysalis-testnet">Chrysalis Testnet</a></h3>
<p>Nodes deployed to the testnet can be queried using a load balancer at:</p>
<ul>
<li>api.lb-0.testnet.chrysalis2.com</li>
</ul>
<p>We recommend using the load balancer for most scenarios.</p>
<p>Single node endpoints that expose native MQTT in case you need this are:</p>
<ul>
<li>api.hornet-0.testnet.chrysalis2.com</li>
<li>api.hornet-1.testnet.chrysalis2.com</li>
<li>api.hornet-2.testnet.chrysalis2.com</li>
<li>api.hornet-3.testnet.chrysalis2.com</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Chrysalis is the most promising series of upgrades made to IOTA yet. It is a major step for our production-readiness, with increased transaction throughput, network stability, improved usability, and enables new features and use cases. The upcoming weeks and months are some of the most exciting in IOTA’s history. We are on a clear path towards IOTA’s adoption as an enabling technology for IoT and beyond.</p>
<h1 id="firefly"><a class="header" href="#firefly">Firefly</a></h1>
<blockquote>
<p>Firefly is IOTA's new official wallet for Chrysalis. </p>
</blockquote>
<p>GitHub: https://github.com/iotaledger/firefly</p>
<h1 id="verify-your-firefly-desktop-download"><a class="header" href="#verify-your-firefly-desktop-download">Verify your Firefly desktop download</a></h1>
<p><strong>When you download Firefly Desktop, you may want to verify its authenticity to make sure that you downloaded the correct one from the IOTA Foundation GitHub repository. In this tutorial, you learn how to verify Firefly Desktop downloads.</strong></p>
<p>To verify the authenticity of Firefly Desktop, you can check its SHA256 hash and its code signature. Instructions for both of these steps differ, depending on your operating system.</p>
<h2 id="windows-operating-system"><a class="header" href="#windows-operating-system">Windows operating system</a></h2>
<h3 id="verify-the-sha256-hash"><a class="header" href="#verify-the-sha256-hash">Verify the SHA256 hash</a></h3>
<ol>
<li>
<p>Open a command-line interface</p>
</li>
<li>
<p>Create a SHA256 hash of the Firefly Desktop <code>.exe</code> file. Replace the path with the path to your Firefly <code>.exe</code> file.</p>
<pre><code>certUtil -hashfile path\to\firefly-desktop-version.exe SHA256
</code></pre>
</li>
</ol>
<pre><code>For example, if the file is in the `C:\Users\yourname\Downloads` directory, do the following:

```
certUtil -hashfile C:\Users\yourname\Downloads\firefly-desktop-1.0.0.exe SHA256
```
</code></pre>
<ol start="3">
<li>Compare your SHA256 hash with the one in the <a href="https://github.com/iotaledger/firefly/releases">release notes</a> and make sure that they match</li>
</ol>
<h3 id="verify-the-code-signature"><a class="header" href="#verify-the-code-signature">Verify the code signature</a></h3>
<ol>
<li>
<p>Right-click on <code>firefly-desktop-version.exe</code></p>
</li>
<li>
<p>Go to <strong>Digital Signatures</strong> &gt; <strong>Details</strong> &gt; <strong>View Certificate</strong></p>
</li>
<li>
<p>In the Certification Path tab, make sure that the the following information matches the path:</p>
<p>DigiCert
DigiCert SHA2 Assured Code Signing CA
IOTA Stiftung</p>
</li>
<li>
<p>Make sure that the Certificate status reads &quot;This certificate is OK.&quot;</p>
</li>
</ol>
<h2 id="macos-operating-system"><a class="header" href="#macos-operating-system">MacOS operating system</a></h2>
<h3 id="verify-the-sha256-hash-1"><a class="header" href="#verify-the-sha256-hash-1">Verify the SHA256 hash</a></h3>
<ol>
<li>
<p>Open Terminal (in <code>/Applications/Utilities/Terminal</code>)</p>
</li>
<li>
<p>Create a SHA256 hash of the Firefly Desktop <code>.dmg</code> file. Replace the path with the path to your Firefly <code>.dmg</code> file.</p>
</li>
</ol>
<pre><code class="language-bash">shasum -a 256 /path/to/firefly-desktop-version.dmg
</code></pre>
<p>For example, if the file is in <code>~/Downloads</code>, do the following:</p>
<pre><code class="language-bash">shasum -a 256 ~/Downloads/firefly-desktop-1.0.0.dmg
</code></pre>
<ol start="3">
<li>Compare your SHA256 hash with the one in the <a href="https://github.com/iotaledger/firefly/releases">release notes</a> and make sure that they match</li>
</ol>
<h3 id="verify-the-code-signature-1"><a class="header" href="#verify-the-code-signature-1">Verify the code signature</a></h3>
<h4 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h4>
<p>To follow these instructions you need <a href="https://www.ics.uci.edu/%7Epattis/common/handouts/macmingweclipse/allexperimental/macxcodecommandlinetools.html">Xcode Command Line Tools</a>.</p>
<ol>
<li>
<p>Open Terminal (in <code>/Applications/Utilities/Terminal</code>)</p>
</li>
<li>
<p>Verify the <code>Firefly.app</code> file's signature. Replace the path with the path to your <code>Firefly.app</code> file. This command confirms whether the code binaries are actually signed, the signature is valid, all the sealed components are unaltered, and the signature passes some basic consistency checks.</p>
<pre><code class="language-bash">codesign -d -vv /path/to/Firefly.app
</code></pre>
<p>For example, if the file is in the <code>/Applications</code> directory, do the following:</p>
<pre><code class="language-bash">codesign -d -vv /Applications/Firefly.app
</code></pre>
</li>
<li>
<p>Make sure that the following information matches the output of the command:</p>
<pre><code class="language-bash">Identifier=org.iota.firefly
Authority=Developer ID Application: IOTA Stiftung (UG77RJKZHH)
Authority=Developer ID Certification Authority
Authority=Apple Root CA
</code></pre>
</li>
<li>
<p>Test the signature against system policies. Replace the path with the path to your <code>Firefly.app</code> file.</p>
<pre><code class="language-bash">spctl -a -vv path/to/Firefly.app
</code></pre>
<p>For example, if the file is in the <code>/Applications</code> directory, do the following:</p>
<pre><code class="language-bash">spctl -a -vv /Applications/Firefly.app
</code></pre>
</li>
<li>
<p>Make sure that the following information matches the output of the command (assuming Firefly is in the <code>/Applications</code> directory):</p>
<p>/Applications/Firefly.app: accepted
source=Developer ID
origin=Developer ID Application: IOTA Stiftung (UG77RJKZHH)</p>
</li>
</ol>
<h2 id="linux-operating-system"><a class="header" href="#linux-operating-system">Linux operating system</a></h2>
<h3 id="verify-the-sha256-hash-2"><a class="header" href="#verify-the-sha256-hash-2">Verify the SHA256 hash</a></h3>
<h4 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h4>
<p>To follow these instructions you need the <code>sha256sum</code> package, which is included with most Linux distributions.</p>
<ol>
<li>
<p>Open Terminal</p>
</li>
<li>
<p>Create a SHA256 hash of the Firefly Desktop executable file. Replace the path with the path to your Firefly executable file.</p>
</li>
</ol>
<pre><code class="language-bash">`sha256sum path/to/firefly-desktop-version.AppImage`
</code></pre>
<p>For example, if the file is in <code>~/Downloads</code>, do the following:</p>
<pre><code class="language-bash">sha256sum ~/Downloads/firefly-desktop-1.0.0.AppImage
</code></pre>
<ol start="3">
<li>Compare your SHA256 hash with the one in the <a href="https://github.com/iotaledger/firefly/releases">release notes</a> and make sure that they match</li>
</ol>
<h3 id="verify-the-code-signature-2"><a class="header" href="#verify-the-code-signature-2">Verify the code signature</a></h3>
<ol>
<li>
<p>Download the .asc and .gpg files in the Assets section of the <a href="https://github.com/iotaledger/firefly/releases">release notes</a></p>
</li>
<li>
<p>Import the Firefly GPG key from keyserver.ubuntu.com</p>
<pre><code class="language-bash">gpg --keyserver keyserver.ubuntu.com --recv 466385BD0B40D9550F93C04746A440CCE5664A64
</code></pre>
</li>
<li>
<p>Make sure that the following information matches the output of the command:</p>
<pre><code class="language-bash">gpg: key 46A440CCE5664A64: public key &quot;IOTA Foundation (IOTA Foundation Identity) &lt;contact@iota.org&gt;&quot;
</code></pre>
</li>
<li>
<p>Verify the signature</p>
<pre><code class="language-bash">gpg --verify path/to/firefly-desktop-version.AppImage.asc path/to/firefly-desktop-version.AppImage
</code></pre>
<p>For example, if the .asc and .AppImage files are both in <code>~/Downloads</code>, do the following:</p>
<pre><code class="language-bash">gpg --verify ~/Downloads/firefly-desktop-1.0.0.AppImage.asc ~/Downloads/firefly-desktop-1.0.0.AppImage
</code></pre>
</li>
<li>
<p>Make sure that the following information matches the output of the command:</p>
<pre><code class="language-bash">gpg: Good signature from &quot;IOTA Foundation (IOTA Foundation Identity) &lt;contact@iota.org&gt;&quot;
</code></pre>
</li>
</ol>
<h1 id="node-software"><a class="header" href="#node-software">Node software</a></h1>
<p>We have been running the network exclusively on the Go powered Hornet node since the summer of 2020. For Chrysalis, you will have the choice to continue using a new version of Hornet or our new Rust-based Bee node.</p>
<h3 id="hornet-and-bee"><a class="header" href="#hornet-and-bee">Hornet and Bee</a></h3>
<p>Moving forward, both Hornet and Bee are the officially supported nodes for IOTA.</p>
<p>Hornet is an EDF-supported community node written in Go and has already proven itself to be a stable and performant implementation. It recently underwent a successful audit. </p>
<p>Bee is an IOTA Node implemented by the Foundation and written in Rust.</p>
<p>At this stage, we recommend using Hornet since it has several optional features that are not implemented in Bee so far.</p>
<h2 id="node-software-1"><a class="header" href="#node-software-1">Node software</a></h2>
<ul>
<li><a href="https://hornet.docs.iota.org">hornet</a></li>
<li><a href="https://github.com/iotaledger/bee/tree/chrysalis-pt-2">bee (branch: chrysalis-pt-2)</a></li>
</ul>
<h2 id="node-api-specification"><a class="header" href="#node-api-specification">Node API specification</a></h2>
<ul>
<li><a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">rest-api specification</a></li>
</ul>
<h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p><strong>The IOTA client libraries allow you to easily integrate IOTA into your own applications. You can choose a library to match your use case.</strong></p>
<p>Official IOTA libraries serve as <code>one-source-code-of-truth</code> to IOTA users and provide binding to other programming languages. You can read more about core principles behind IOTA client libraries in the following blog <a href="https://blog.iota.org/the-new-iota-client-libraries-harder-better-faster-stronger/">post</a>.</p>
<ul>
<li><a href="libraries/client.html">client-lib</a>: a general purpose IOTA client library for interacting with the IOTA network (Tangle)</li>
<li><a href="libraries/wallet.html">wallet-lib</a>: a stateful library specifically designed to be used for IOTA value-based transfers </li>
<li><a href="https://github.com/iotaledger/iota.c">iota.c</a>: a special-purpose library in C for embedded devices (with microcontrollers) covering a basic features of <code>client-lib</code> or <code>wallet-lib</code></li>
<li><a href="https://github.com/iotaledger/iota.js/tree/chrysalis">iota.js</a>: an initial IOTA client library in Typescript that can be used in a web browser</li>
<li><a href="https://github.com/iotaledger/iota.go/tree/chrysalis/phase2">iota.go</a>: an initial IOTA client library in Golang</li>
</ul>
<div class="iframe-wrapper">
<iframe src="https://www.youtube.com/embed/N2VW3zJQmso" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p><img src="libraries/../guides/assets/overview-libraries.svg" alt="overview-libs" /></p>
<p>All libraries are in active development. The libraries target the Chrysalis testnet and do not work with current IOTA mainnet.</p>
<p>The client libraries with official support are maintained by the IOTA Foundation, their source code can be found on the <a href="https://github.com/iotaledger">Official GitHub repository</a>.</p>
<h2 id="utilities"><a class="header" href="#utilities">Utilities</a></h2>
<h4 id="developer-tools"><a class="header" href="#developer-tools"><strong>Developer tools</strong></a></h4>
<ul>
<li><a href="https://explorer.iota.org/chrysalis">Official explorer</a></li>
<li><a href="https://faucet.testnet.chrysalis2.com/">Testnet faucet</a></li>
<li><a href="https://github.com/iotaledger/cli-wallet">Commandline wallet</a></li>
</ul>
<hr />
<h1 id="iota-client-library"><a class="header" href="#iota-client-library">IOTA Client Library</a></h1>
<p>The official client library for interacting with the IOTA Tangle allows you to:</p>
<ul>
<li>Create messages and transactions</li>
<li>Sign transactions</li>
<li>Generate addresses</li>
<li>Interact with an IOTA node</li>
</ul>
<p>If you mainly intend to process value transfers, we recommend you use our stateful <a href="libraries/./wallet.html">wallet library</a> instead.</p>
<p><a href="https://client-lib.docs.iota.org">IOTA Client Library full documentation</a></p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/rust/getting_started.html">Getting Started</a> - Getting Started with Rust and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/rust/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/docs/iota/index.html">API Documentation</a> - The IOTA Client Library Rust API Documentation.</li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/getting_started.html">Getting Started</a> - Getting Started with Node.js and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/libraries/nodejs/api_reference.html">API Documentation</a> - The IOTA Client Library Node.js API Documentation.</li>
</ul>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<ul>
<li><a href="https://client-lib.docs.iota.org/libraries/python/getting_started.html">Getting Started</a> - Getting Started with Python and the IOTA Client Library.</li>
<li><a href="https://client-lib.docs.iota.org/libraries/python/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.rs/tree/dev/bindings/python">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://client-lib.docs.iota.org/libraries/python/api_reference.html">API Documentation</a> - The IOTA Client Library Python API Documentation.</li>
</ul>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<ul>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/index.html">Getting Started</a> - Getting Started with C and the IOTA Client Library.</li>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/client_examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/iota.c">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://iota-c-client.readthedocs.io/en/latest/api/client.html">API Documentation</a> - The IOTA Client Library C API Documentation.</li>
</ul>
<h1 id="iota-wallet-library"><a class="header" href="#iota-wallet-library">IOTA Wallet Library</a></h1>
<p>The wallet library is a stateful library for developers; essentially it's a programmable wallet. It is recommended you use this library if you are mainly using IOTA for token transfers. This library supports the handling and monitoring multiple account/addresses at the same time. Its stateful design allows a management of multiple accounts and addresses in an effective manner.</p>
<p>In addition to this, it also supports the <a href="https://github.com/iotaledger/stronghold.rs">Stronghold.rs</a> enclave, incorporating the best security practices in one package:</p>
<p><a href="https://wallet-lib.docs.iota.org">IOTA Wallet Library full documentation</a></p>
<h2 id="rust-1"><a class="header" href="#rust-1">Rust</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/rust/getting_started.html">Getting Started</a> - Getting Started with Rust and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/rust/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/docs/iota_wallet/index.html">API Documentation</a> - The IOTA Wallet Library Rust API Documentation.</li>
</ul>
<h2 id="nodejs-1"><a class="header" href="#nodejs-1">Node.js</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/getting_started.html">Getting Started</a> - Getting Started with Node.js and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs/tree/develop/bindings/nodejs">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html">API Documentation</a> - The IOTA Wallet Library Node.js API Documentation.</li>
</ul>
<h2 id="python-1"><a class="header" href="#python-1">Python</a></h2>
<hr />
<ul>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/getting_started.html">Getting Started</a> - Getting Started with Python and the IOTA Wallet Library.</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/examples.html">Examples</a> - Find starting points or inspiration in the examples.</li>
<li><a href="https://github.com/iotaledger/wallet.rs/tree/develop/bindings/python">Repository</a> - Browse through the code and learn what's happening behind the scenes. Pull requests are very welcome!</li>
<li><a href="https://wallet-lib.docs.iota.org/libraries/python/api_reference.html">API Documentation</a> - The IOTA Wallet Library Python API Documentation.</li>
</ul>
<h1 id="iota-chrysalis-guides"><a class="header" href="#iota-chrysalis-guides">IOTA Chrysalis Guides</a></h1>
<ul>
<li><a href="guides/./dev_guide.html">Developer Guide</a></li>
<li><a href="guides/./exchange_guide.html">Exchange Guide</a></li>
<li><a href="guides/./token_guide.html">Token Migration Guide</a></li>
<li><a href="guides/./hub_guide.html">Hub Migration Guide</a></li>
</ul>
<h2 id="overall-changes-from-iota-10-to-15-chrysalis-in-a-nutshell"><a class="header" href="#overall-changes-from-iota-10-to-15-chrysalis-in-a-nutshell">Overall changes from IOTA 1.0 to 1.5 (Chrysalis) in a nutshell</a></h2>
<ul>
<li>The format of the address was changed and it is based on both <code>derivation path</code> and <code>bech32</code> standards. See <a href="guides/./dev_guide.html#iota-15-address-anatomy">IOTA address anatomy</a></li>
<li>The concepts of <code>bundles</code> and <code>transactions</code> were replaced with the concepts of <code>messages</code> and <code>payloads</code>. The <code>message</code> is a data structure that is actually being broadcast in the network and represents a node (vertex) in the Tangle graph. See <a href="guides/./dev_guide.html#messages-payload-and-transactions">messages, payload and transactions</a> and <a href="guides/./dev_guide.html#selected-message-payloads">selected message payloads</a></li>
<li>The IOTA network is based on a DAG (Directed Acyclic Graph) to store individual <code>messages</code> (and related <code>transactions</code>). However, each <code>message</code> can newly reference up to 8 parent messages. See <a href="guides/./dev_guide.html#messages-payload-and-transactions">messages, payload and transactions</a></li>
<li>The signature scheme based on <code>WOTS</code> was replaced with with <code>Ed25519</code> signature scheme. See <a href="guides/./dev_guide.html#seed-and-addresses">seed and addresses</a></li>
<li>Due to the changed signature scheme, IOTA addresses are reusable without any negative security impact</li>
<li>In comparison to IOTA 1.0, which was based on ternary, IOTA 1.5 is based on binary and is thus very efficient on all kinds of current hardware devices</li>
<li>In contrast to IOTA 1.0, IOTA 1.5 addresses are perfectly reusable; even if one spends funds from the given address, it can be used again. See <a href="guides/./dev_guide.html#addresskey-space">address/key space</a></li>
<li>Originally, IOTA 1.0 used an <code>account-based model</code> for tracking individual iota tokens. Chrysalis embraced <code>Unspent Transaction Output</code> (also known as <code>UTXO</code>) model to track tokens and token holders. See <a href="guides/./dev_guide.html#unspent-transaction-output-utxo">Unspent Transaction Output</a></li>
<li>The approach to client libraries was completely reengineered from the ground up. There are new official client libraries that serve as <code>one-source-code-of-truth</code> to IOTA users and can be combined in a modular fashion based on particular use cases. All libraries provide a binding to other programming languages. See <a href="guides/../libraries/overview.html">client libraries</a></li>
<li>Our official iota tools, such as wallet software, use the same libraries under the hood and so any developer may taste the same <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">dog food</a> as we do</li>
<li>The official client libraries embraced <code>Hierarchical Deterministic Wallets</code> approach which is fully <code>BIP44</code> compatible. See <a href="guides/./dev_guide.html#addresskey-space">address/key space</a></li>
<li>There is a new official wallet software called Firefly. See <a href="https://blog.iota.org/firefly-beta-release/">firefly beta release</a></li>
</ul>
<h1 id="developer-guide-to-chrysalis"><a class="header" href="#developer-guide-to-chrysalis">Developer guide to Chrysalis</a></h1>
<p>This is a quick guide meant to help you navigate through some of the differences you will encounter while migrating from IOTA 1.0 to IOTA 1.5, also known as Chrysalis.</p>
<h2 id="seed-and-addresses"><a class="header" href="#seed-and-addresses">Seed and addresses</a></h2>
<p>In Chrysalis, all ternary conversions apart from PoW have been removed which results in a better, faster developer experience. Additionally, the WOTS-Signature has been replaced by a <code>Ed25519</code> signature scheme. This means that you can now use an address multiple times to send and receive coins.</p>
<p>With these changes, and the further adoption of industry standards, both seeds and addresses will look completely different in IOTA Chrysalis.</p>
<p>IOTA 1.0 address:</p>
<pre><code class="language-bash=">UDYXTZBE9GZGPM9SSQV9LTZNDLJIZMPUVVXYXFYVBLIEUHLSEWFTKZZLXYRHHWVQV9MNNX9KZC9D9UZWZRGJMIGPDW
</code></pre>
<p>IOTA 1.5 (Chrysalis) address (bech32 standard):</p>
<p>Mainnet with <code>iota</code></p>
<pre><code class="language-bash=">iota1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m759nh2ml
</code></pre>
<p>Testnet with <code>atoi</code></p>
<pre><code class="language-bash=">atoi1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m75zaxtpj
</code></pre>
<h3 id="iota-15-address-anatomy"><a class="header" href="#iota-15-address-anatomy">IOTA 1.5 address anatomy</a></h3>
<p>The IOTA address is based on the Ed25519 signature scheme and it is usually represented by the Bech32 (checksummed base32) format string of 64 characters or hex format:</p>
<table>
    <thead>
        <tr>
            <th colspan=4><center>iota1qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m759nh2ml</center></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan=4><center>three distinguished parts</center></td>
        </tr>
        <tr>
            <td><center><strong>human-readable id</strong></center></td>
            <td><center><strong>separator</strong></center></td>
            <td><center><strong>data</strong></center></td>
            <td><center><strong>checksum</strong></center></td>
        </tr>
        <tr>
            <td><center>iota | atoi</center></td>
            <td><center>1</center></td>
            <td><center>48 bytes [0..9a..z]</center></td>
            <td><center>6 characters [0..9a..z]</center></td>
        </tr>
        <tr>
            <td><center>iota</center></td>
            <td><center>1</center></td>
            <td><center>qpw6k49dedaxrt854rau02talgfshgt0jlm5w8x9nk5ts6f5x5m75</center></td>
            <td><center>9nh2ml</center></td>
        </tr>
        <tr>
            <td colspan=4>iota = mainnet; atoi = testnet</td>
        </tr>
    </tbody>
</table>
<p>More information: <a href="https://github.com/Wollac/protocol-rfcs/blob/bech32-address-format/text/0020-bech32-address-format/0020-bech32-address-format.md">Protocol-rfc#0020</a></p>
<h3 id="seed"><a class="header" href="#seed">Seed</a></h3>
<p>With the new <a href="guides/../libraries/wallet.html">wallet library</a>, developers do not need to use a self-generated seed anymore. By default, the seed is created and stored in Stronghold, our in-house built security enclave. It is not possible to extract the seed from Stronghold for security purposes. Stronghold uses encrypted snapshots that can easily be backed up and securely shared between devices. These snapshots are then further secured with a password.</p>
<p>More information about IOTA Wallet Library is available on <a href="https://wallet-lib.docs.iota.org">Wallet docs page</a> or in the <a href="guides/exchange_guide.html">Exchange guide</a>, which is mainly focused on value transactions.</p>
<blockquote>
<p>Please note, it is highly recommended to NOT use online seed generators at all. The seed is the only key to the given funds.</p>
</blockquote>
<p>A root of the <code>Ed25519</code> signature scheme is basically a <code>32-byte (256-bit)</code> uniformly randomly generated seed based on which all private keys and corresponding addresses are generated. A seed may be represented by a string of 64 characters using <code>[0-9a-f]</code> alphabet (32 bytes encoded in hexadecimal).</p>
<p>The seed can be, for example, generated using the SHA256 algorithm on some random input generated by cryptographically secure pseudo-random generator, such as <a href="https://client-lib.docs.iota.org/libraries/python/examples.html#generating-seed-and-addresses">os.urandom()</a>.</p>
<p>Seed examples (a single seed per line):</p>
<pre><code class="language-plaintext">4892e2265c45734d07f220294b1697244a8ab5beb38ba9a7d57aeebf36b6e84a
37c4aab22a5883595dbc77907c1626c1be39d104df39c5d5708423c0286aea89
e94346bce41402155ef120e2525fad2d0bf30b10a89e4b93fd8471df1e6a0981
...
</code></pre>
<blockquote>
<p>In modern wallet implementations, such as our <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs library</a> and <a href="https://blog.iota.org/firefly-beta-release/">firefly wallet</a>, the seed is usually generated from a <code>seed mnemonic</code> (<code>seed phrase</code>), using <a href="https://en.bitcoin.it/wiki/BIP_0039">BIP39 standard</a>, to be better memorized/stored by humans. It is based on randomly generated list of english words and is later used to generate the seed. Either way, the seed is a root for all generated private keys and addresses</p>
</blockquote>
<p><a href="https://github.com/Wollac/protocol-rfcs/blob/mnemonic-seed/text/0010-mnemonic-ternary-seed/0010-mnemonic-ternary-seed.md">Protocol-rfc#0010</a></p>
<h3 id="addresskey-space"><a class="header" href="#addresskey-space">Address/key space</a></h3>
<p>As mentioned above, IOTA 1.5 embraced some existing industry standards, which is obvious even during an address generation process. This includes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a> standard that describes an approach to <em>Hierarchical Deterministic Wallets</em>. The standard was improved by <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> recently.</p>
<p>These standards define a tree structure as a base for address and key space generation which is represented by a <code>derivation path</code>:</p>
<pre><code class="language-plaintext">m / purpose / coin_type / account / change / address_index
</code></pre>
<ul>
<li><code>m</code>: a master node (seed)</li>
<li><code>purpose</code>: constant which is {44}</li>
<li><code>coin_type</code>: a constant set for each crypto currency. IOTA = 4218, for instance.</li>
<li><code>account</code>: account index. Zero-based increasing <code>int</code>. This level splits the address/key space into independent branches (ex. user identities) which each has own set of addresses/keys</li>
<li><code>change</code>: change index which is <code>{0, 1}</code>, also known as <code>wallet chain</code>.<br />
There are two independent chain of addresses/keys. <code>0</code> is reserved for public addresses (for coin receival) and <code>1</code> is reserved for internal (also known as change) addresses to which a transaction change is returned. <em>In comparison to IOTA 1.0, IOTA 1.5 is fine with address reuse, and so it is, technically speaking, valid to return transaction change to the same originating address. It is up to developers whether to leverage it or not. <code>iota.rs</code> library and its sibling <code>wallet.rs</code> help with either scenario</em>.</li>
<li><code>address_index</code>: address index. Zero-based increasing <code>int</code> that indicates an address index</li>
</ul>
<p>As outlined, there is a  large address/key space that is secured by a single seed.</p>
<p>And there are few additional things to note:</p>
<ul>
<li>Each level defines a completely different subtree (subspace) of addresses/keys and those are never mixed up</li>
<li>The hierarchy is ready to &quot;absorb&quot; addresses/keys for  different coins at the same time (<code>coin_type</code>) and all those coins are secured by the same seed</li>
<li>There may be also other <code>purposes</code> in the future. However, let's consider a single purpose as of now. The constant <code>44</code> stands for BIP44.</li>
<li>The standard was agreed upon different crypto communities, although not all <code>derivation path</code> components are always in active use. For example, <code>account</code> is not always actively leveraged across crypto space (if this is a case then there is usually <code>account=0</code> used)</li>
<li>Using different <code>accounts</code> may be useful to split addresses/key into some independent spaces and it is up to developers to implement.<br /></li>
</ul>
<p><em>Please note, having many different accounts may have a negative impact on performance while <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery">account discovery</a> phase. So, if you are after using multiple, different accounts then you may be interested in our stateful library <a href="https://chrysalis.docs.iota.org/libraries/wallet.html">wallet.rs</a> that incorporates all business logic needed to efficiently manage independent accounts. Additionally, our <a href="https://chrysalis.docs.iota.org/guides/exchange_guide.html">exchange guide</a> provides some useful tips how different accounts may be leveraged.</em></p>
<p><img src="guides/assets/address_generation.svg" alt="address_generation" /></p>
<p>So in case of IOTA 1.5 (Chrysalis), the derivation path of address/key space is <code>[seed]/44/4218/{int}/{0,1}/{int}</code>:</p>
<ul>
<li>The levels <code>purpose</code> and <code>coin_type</code> are given</li>
<li>The rest levels are up to developers to integrate, specifically <code>seed</code>, <code>account</code>, <code>wallet_chain</code> and <code>address_index</code></li>
</ul>
<p><a href="https://github.com/iotaledger/protocol-rfcs/blob/ee07797acb5940b7dbb5c3411b184ccdc6afdbb1/text/0000-ed25519-signature-scheme/0000-ed25519-signature-scheme.md">Protocol-rfc#0003</a></p>
<h2 id="messages-payloads-and-transactions"><a class="header" href="#messages-payloads-and-transactions">Messages, payloads, and transactions</a></h2>
<p>In comparison to original the IOTA 1.0, IOTA 1.5 also introduced some fundamental changes to the underlying data structures. The original concept of <code>transactions</code> and <code>bundles</code> is gone, and has been replaced by a concept of <code>messages</code> and <code>payloads</code>.</p>
<p>A <code>message</code> is a data structure that is actually being broadcast in the IOTA 1.5 network and represents a node (vertex) in the Tangle graph.</p>
<p>It can refer to up to 8 previous messages and once a message is attached to the Tangle and approved by a milestone, the Tangle structure ensures the content of the message is unaltered. Every message is referenced by a <code>message_id</code> which is based on a hash algorithm (<code>Blake2b256</code>) of binary content of the message. It also includes previous Tangle messages as its <code>parents</code> which means it is not possible to alter the given message without altering previous messages in the Tangle.</p>
<p>The <code>message</code> is an atomic unit that is confirmed by the network as a whole.</p>
<blockquote>
<p>IOTA is no longer based on ternary. IOTA 1.5 uses binary to encode and broadcast all underlying data entities</p>
</blockquote>
<p>A <code>message</code> is arbitrary in size (up to 35 kB) and it can hold variable sets of information called <code>payloads</code>. The number of payloads a single message can encapsulate is not given. Even a message without a <code>payload</code> is completely valid and can be broadcast. The <code>Message</code> itself does not include any timestamp; a message timestamp is derived from an acceptance of the given message by the Tangle network.</p>
<p>A<code>payload</code> represents a layer of concern. Some payloads may change a state of the ledger (ex. <code>SignedTransactions</code>) and some may provide extra features to some specific applications and business use cases (ex. <code>IndexationPayload</code>).</p>
<p>There are already implemented core payloads, such as <code>SignedTransaction</code>, <code>MilestonePayload</code>, and <code>IndexationPayload</code> but the message and payload definition is generic enough to incorporate any future payload(s) the community agrees upon.</p>
<p>Needless to say, the IOTA network ensures the outer structure of the message itself is valid and strictly complies with network consensus protocol. However, the inner structure is very flexible, future-proof, and offers an unmatched network extensibility.</p>
<p><img src="guides/assets/messages_in_tangle.svg" alt="messages_in_tangle" /></p>
<p>The current IOTA 1.5 network incorporates the following core payloads:</p>
<ul>
<li><code>SignedTransaction</code>: a payload that describes <code>UTXO</code> transactions that are the cornerstones of value-based transfers in IOTA network. Via this payload, a <code>message</code> can be also cryptographically signed</li>
<li><code>MilestonePayload</code>: a payload that is emitted by the Coordinator</li>
<li><code>IndexationPayload</code>: a payload that enables the addition of an index to the encapsulating message, as well as some arbitrary data. The given index can be later used to search the message(s).</li>
</ul>
<p>In comparison to IOTA 1.0, a <code>message</code> itself is not directly related to the IOTA address while broadcasting to the IOTA 1.5 network. Such messages are referenced using <code>message_id</code>. Messages are indirectly related to IOTA addresses via <code>SignedTransaction</code> payload, specifically the <code>UTXO</code> section.</p>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Protocol-rfc#0017</a>; 
<a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0018</a></p>
<h2 id="unspent-transaction-output-utxo"><a class="header" href="#unspent-transaction-output-utxo">Unspent Transaction Output (UTXO)</a></h2>
<p>Originally, IOTA 1.0 used an <code>account-based model</code> for tracking individual iota tokens: <em>each IOTA address held a number of tokens and the aggregated number of tokens from all iota addresses was equal to the total supply.</em></p>
<p>In contrast, IOTA 1.5 uses the <code>unspent transaction output</code> model, or <code>UTXO</code>. It is based on an idea to track unspent amounts of tokens via a data structure called <code>output</code>.</p>
<p>Below is a simplified analogy of how the UTXO works:</p>
<ul>
<li>There are 100 tokens recorded in the ledger as <code>Output A</code> and this output belongs to Alice. So, the <strong>initial state of the ledger</strong>: <code>Output A</code> = 100 tokens</li>
<li>Alice sends 20 tokens to Paul, 30 tokens to Linda, and keeps 50 tokens at her disposal</li>
<li>Her 100 tokens are recorded as <code>Output A</code> so she has to divide (spent) tokens and create three new outputs:<br /><code>Output B</code> with 20 tokens that goes to Paul, <code>Output C</code> with 30 tokens that goes to Linda, and finally <code>Output D</code> with the rest of the 50 tokens that she kept for herself</li>
<li><strong>Original <code>Output A</code></strong> was completely spent and cannot be used any more. It has been spent and so <strong>becomes irrelevant</strong> to ledger state.</li>
<li><strong>New state of ledger</strong>: <code>Output B</code> = 20 tokens, <code>Output C</code> = 30 tokens and <code>Output D</code> = 50 tokens</li>
<li>The total supply remains the same, just number of outputs differs and some outputs were replaced by other outputs in the process</li>
</ul>
<p><img src="guides/assets/utxo.svg" alt="utxo" /></p>
<p>The key takeaway of the outlined process above is the fact that each unique <code>output</code> can be spent <strong>only once</strong>. Once the given <code>output</code> is spent, it cannot be used any more and is irrelevant in regards to the ledger state.</p>
<p>So even if Alice still wants to keep remaining tokens at her fingertips, those tokens have to be moved to a completely new <code>output</code> that can be, for instance, still tied to the Alice's same iota address as before.</p>
<p>Every <code>output</code> also stores information about an IOTA address to which it is coupled with. So addresses and tokens are indirectly coupled via <code>outputs</code>. Basically, the sum of outputs and their amounts under the given address is a balance of the given address, ie., the number of tokens the given address can spend. And the sum of all unspent outputs and their amounts is equal to the total supply.</p>
<p><code>Outputs</code> are being broadcasted encapsulated in a <code>message</code> as a part of <code>SignedTransaction</code> payload.</p>
<p><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0018</a></p>
<h2 id="selected-message-payloads"><a class="header" href="#selected-message-payloads">Selected message payloads</a></h2>
<p>Currently, there are two commonly used message payloads, <code>IndexationPayload</code> and <code>SignedTransaction</code> which can be combined based as needed.</p>
<p><a href="https://github.com/luca-moser/protocol-rfcs/blob/signed-tx-payload/text/0000-transaction-payload/0000-transaction-payload.md">Protocol-rfc#0000</a></p>
<h3 id="indexationpayload"><a class="header" href="#indexationpayload">IndexationPayload</a></h3>
<p><code>IndexationPayload</code> is a payload type that can be used to attach an arbitrary <code>data</code> and key <code>index</code> to a message. When this particular payload is leveraged, then a message and related data entity can be searched via key <code>index</code> in addition to a <code>message_id</code>.</p>
<h3 id="signedtransaction"><a class="header" href="#signedtransaction">SignedTransaction</a></h3>
<p><code>SignedTransaction</code> is a payload type that is used to transfer value-based messages as <code>UTXO</code>. It changes the ledger state as old <code>outputs</code> are being spent (replaced) and new <code>outputs</code> are being created.</p>
<p>Each <code>SignedTransaction</code> includes the following set of information:</p>
<ul>
<li><code>inputs</code> - a list of valid <code>outputs</code> that should be used to fund the given transaction. Outputs are uniquely referenced via previous <code>transaction_id</code> and inner <code>index</code>. At least one output has to be given with enough balance to source all <code>outputs</code> of the given message</li>
<li><code>outputs</code> - a list of IOTA address(es) and related amount(s) the input <code>outputs</code> should be split among. Based on this information, new <code>UTXO</code> outputs are being created</li>
<li><code>unlock_blocks</code> - it includes a transaction signature(s) (currently based on <code>Ed25519</code> scheme) that proves token ownership based on a valid seed</li>
</ul>
<h2 id="dust-protection"><a class="header" href="#dust-protection">Dust protection</a></h2>
<p>Since IOTA is feeless and has the ability to send microtransactions, attackers could use this to spam the network with very low value transactions, which we call dust. To avoid this, we only allow microtransaction below 1Mi (dust) of IOTA tokens to another address if you already have at least 1Mi as a dust allowance output on that address. The number of allowed dust outputs on an address is the amount of the dust allowance outputs divided by 100,000 and rounded down, i.e. 10 outputs for each 1 Mi deposited, with a maximum of 100 dust outputs in total.</p>
<blockquote>
<p>In the UTXO model, each node in the network needs to keep track of all the currently unspent outputs. When the number of outputs becomes too large, it can cause performance and memory issues. The RFC below proposes a new protocol rule regarding the processing of outputs where they transfer a very small amount of IOTA’s so-called dust outputs. Dust outputs are only allowed when they are backed up by a certain deposit on the receiving address. This limits the amount of dust outputs, thus making it expensive to proliferate dust. Since a receiver must make a deposit, the protocol makes receiving dust an opt-in feature.</p>
</blockquote>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/dust/text/0032-dust-protection/0032-dust-protection.md">Protocol-rfc#0032</a></p>
<h2 id="up-to-8-parents"><a class="header" href="#up-to-8-parents">Up to 8 Parents</a></h2>
<p>With IOTA 1.0, you always had to reference 2 parent transactions. With Chrysalis, we introduce a more dynamic number of parent nodes where you can reference up to 8 parents. We recommend you reference at least 2 unique parents at all times for the best possible results.</p>
<p><a href="https://github.com/GalRogozinski/protocol-rfcs/blob/message/text/0017-message/0017-message.md">Protocol-rfc#0017</a></p>
<h1 id="exchange-guide"><a class="header" href="#exchange-guide">Exchange guide</a></h1>
<h2 id="the-iota-wallet-library"><a class="header" href="#the-iota-wallet-library">The IOTA wallet library</a></h2>
<blockquote>
<p>Easily integrate IOTA with your exchange, custody solution, or product.</p>
</blockquote>
<p>IOTA is built on an architecture that was designed to be the backbone of the Internet of Things (IoT) environment of the future. But this architecture has made it more challenging for service providers like exchanges to integrate IOTA compared to traditional blockchain-based distributed ledgers.</p>
<p>Within the Chrysalis update (also known as IOTA 1.5), some building blocks have been changed to be more approachable and more aligned with currently leveraged standards. We also ship many <a href="guides/../libraries/overview.html">client libraries</a> to help developers implement IOTA into their applications:
<img src="guides/assets/wallet_rs_layers.svg" alt="layers" /></p>
<h2 id="how-do-i-implement-it-to-my-exchange"><a class="header" href="#how-do-i-implement-it-to-my-exchange">How do I implement it to my exchange?</a></h2>
<p>In <a href="guides/../libraries/wallet.html">wallet.rs</a>, we use an account model so you can create an account for each of your users. Another approach would be to use one account and generate multiple addresses, which you can then link to the users in your database. The wallet library is designed to be as flexible as possible to back up any of your use cases.</p>
<p>Since IOTA addresses in the Chrysalis network are perfectly reusable, they can be mapped to your users in a clear and concise way:</p>
<ul>
<li>Create an account for every user -&gt; <code>Multi Account</code> approach</li>
<li>Create one account with many addresses -&gt; <code>Single account</code> approach</li>
</ul>
<p>The library supports derivation for multiple accounts from a single seed. An account is simply a deterministic identifier from which multiple addresses can be further derived. </p>
<p>The library also allows consumers to assign a meaningful alias to each account. In addition to this, generated individual accounts can be also searched via generated addresses. This means it does not matter whether aliases or addresses are known as the search for the related account is very straightforward using the <code>wallet.rs</code> library.</p>
<p>It also leaves the choice to users if they want to segregate their funds across multiple accounts or multiple addresses. The following illustration outlines the relationships between seed, accounts, and addresses: </p>
<p><img src="guides/assets/accounts.svg" alt="accounts" /></p>
<h3 id="multi-account-approach"><a class="header" href="#multi-account-approach">Multi account approach</a></h3>
<p>The multi account approach is used to create an account for each individual user. The created accounts can then be linked to the internal user IDs as an account alias, which are distinctly separated.</p>
<h3 id="single-account-approach"><a class="header" href="#single-account-approach">Single account approach</a></h3>
<p>The single account approach allows for just one account and creates addresses for each individual user. The associated addresses are then linked to the internal user IDs and store who owns which address in the database. Most exchanges are more familiar with the single account approach and find it easier to use, implement, and backup.</p>
<h2 id="implementation-guide"><a class="header" href="#implementation-guide">Implementation guide</a></h2>
<p>This guide explains how to use the IOTA Wallet Library to successfully implement IOTA into an exchange. If you already implemented the IOTA Hub, please visit the <a href="guides/./hub_guide.html">Hub Migration Guide</a>.</p>
<p>Features of the Wallet Library:</p>
<ul>
<li>Secure seed management</li>
<li>Account management (with multiple accounts and multiple addresses)</li>
<li>Confirmation monitoring</li>
<li>Deposit address monitoring</li>
<li>Backup and restore functionality</li>
</ul>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>The Wallet Library is a stateful package with a standardized interface for developers to build applications involving IOTA value transactions. It offers abstractions to handle IOTA payments and can optionally interact with the IOTA Stronghold for seed handling, seed storage, and state backup. Alternatively, you can use a SQLite database; however, using the Stronghold component is highly recommended due to the most advanced level of security being applied.</p>
<p>For reference, you can see the <a href="https://wallet-lib.docs.iota.org">full documentation here</a>.</p>
<p>The following examples cover the <em>multi account approach</em> using <code>NodeJS</code> binding:</p>
<ol>
<li>Setup the Wallet Library</li>
<li>Create an account for each user</li>
<li>Generate a user address for deposits</li>
<li>Listen to events</li>
<li>Check the user balance</li>
<li>Enable withdrawals</li>
</ol>
<p><em>Note: If you are looking for other languages, please read the <a href="guides//libraries/wallet.html">wallet library overview</a>.</em></p>
<p>Since all <code>wallet.rs</code> bindings are based on core principles provided by the <code>wallet.rs</code> library, the outlined approach is very similar regardless of the programming language of your choice.</p>
<h3 id="1-setup-the-wallet-library"><a class="header" href="#1-setup-the-wallet-library">1. Setup the Wallet library</a></h3>
<p>First, let's install the components that are needed to use <code>wallet.rs</code> and the binding of your choice; it may vary a bit from language to language. In the case of the <code>NodeJs</code> binding, it is quite straightforward since it is distributed via the <code>npm</code> package manager. We also recommend you use <code>dotenv</code> for password management.</p>
<p>For reference, read more about <a href="guides/backup_security.html">backup and security here</a>.</p>
<pre><code class="language-bash">npm install @iota/wallet dotenv
touch .env
</code></pre>
<p>Then, input your password to the <code>.env</code> file like this:</p>
<pre><code class="language-bash">SH_PASSWORD=&quot;here is your super secure password&quot;
</code></pre>
<p>Once you have everything needed to use the <code>wallet.rs</code> library, it is necessary to initialize the <code>AccountManager</code> instance which creates (opens) a secure storage for individual accounts (backed up by <code>Stronghold</code> by default).</p>
<p>The storage is encrypted at rest, so you need a strong password and location where to put your storage. </p>
<p><em>Note: manage your password with the utmost care</em>.</p>
<p>Technically speaking, &quot;storage&quot; means a single file called <code>wallet.stronghold</code>. It is also needed to generate a seed (mnemonic) that serves as a cryptographic key from which all accounts and related addresses are generated.</p>
<p>One of the key principles behind the <code>stronghold</code>-based storage is that no one can get a seed from the storage. You deal with all the accounts purely via the <code>Account_Manager</code> instance where all complexities are hidden under the hood and are dealt with in a secure way. In case you would also like to store a seed somewhere else, there is another method, <code>AccountManager.generateMnemonic()</code>, that generates random seeds. This method can be leveraged before the actual account initialization.</p>
<p>Note that it is highly recommended to store the <code>stronghold</code> password and the <code>stronghold</code> database on separate devices. Please refer to the <a href="guides/backup_security.html">backup and security guide</a> for more information.</p>
<p>Import the Wallet Library and create an account manager:</p>
<pre><code class="language-javascript">    const { AccountManager, SignerType } = require('@iota/wallet')

    // Setup IOTA Wallet Library
    const manager = new AccountManager({
        storagePath: './storage'
    })
    manager.setStrongholdPassword(process.env.SH_PASSWORD)
    manager.storeMnemonic(SignerType.Stronghold, manager.generateMnemonic()) // seed generation
</code></pre>
<p>Once the stronghold storage is created, it is not needed to generate the seed any longer (<code>manager.storeMnemonic(SignerType.Stronghold, manager.generateMnemonic())</code>). It has been already saved in the storage together with all account information.</p>
<h3 id="2-create-an-account-for-an-user"><a class="header" href="#2-create-an-account-for-an-user">2. Create an account for an user</a></h3>
<p>Once the backend storage is created, individual accounts for individual users can be created:</p>
<pre><code class="language-javascript">    let account = await manager.createAccount({
        alias: user_id,  // an unique id from your existing user
        clientOptions: { node: 'http://api.lb-0.testnet.chrysalis2.com', localPow: false }
    })
</code></pre>
<p>Each account is related to a specific IOTA network (mainnet/devnet) which is referenced by a node property, such as node url (in this example, the Chrysalis testnet balancer).</p>
<p>For more information about <code>clientOptions</code>, please refer to <a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html">Wallet NodeJs API Reference</a>.</p>
<p>The <code>Alias</code> can be whatever fits to the given use case and should be unique. The <code>alias</code> is usually used to identify the given account later on. Each account is also represented by an <code>index</code> which is incremented (by 1) every time a new account is created. Any account can be then referred to via <code>index</code>, <code>alias</code>, or one of its generated <code>addresses</code>.</p>
<p>Once an account has been created, you get an instance of it using the following methods: <code>AccountManager.getAccount(accountId)</code>, <code>AccountManager.getAccountByAlias(alias)</code> or <code>AccountManager.getAccounts()</code>.</p>
<p>The most common methods of <code>account</code> instance include:</p>
<ul>
<li><code>account.alias()</code> - returns an alias of the given account</li>
<li><code>account.listAddresses()</code> - returns list of addresses related to the account</li>
<li><code>account.getUnusedAddress()</code> - returns a first unused address</li>
<li><code>account.generateAddress()</code> - generate a new address for the address index incremented by 1</li>
<li><code>account.balance()</code> - returns the balance for the given account</li>
<li><code>account.sync()</code> - sync the account information with the tangle</li>
</ul>
<h3 id="3-generate-a-user-address-to-deposit-funds"><a class="header" href="#3-generate-a-user-address-to-deposit-funds">3. Generate a user address to deposit funds</a></h3>
<p><code>Wallet.rs</code> is a stateful library which means it caches all relevant information in storage to provide performance benefits while dealing with, potentially, many accounts/addresses.</p>
<p><em>Note: sync the account info with the network during the wallet manipulation to be sure the storage reflects an actual state of the ledger (network)</em>. </p>
<p>Every account can own multiple addresses. Addresses are represented by an <code>index</code> which is incremented (by 1) every time a new address is created. The latest address is accessible via <code>account.latestAddress()</code>: </p>
<pre><code class="language-javascript">    // Always sync before account interactions
    console.log('syncing...')
    const synced = await account.sync()
    console.log('synced!')

    // By design, the last address of each account is an unused address which can be used as deposit address
    const latestAddress = account.latestAddress()

    console.log('Need a refill? Send it to this address:', latestAddress)
</code></pre>
<p>Feel free to fill the address with Testnet Tokens with the <a href="https://faucet.testnet.chrysalis2.com/">IOTA Faucet</a> to test it.</p>
<p>Addresses are of two types, <code>internal</code> and <code>public</code> (external):</p>
<ul>
<li>Each set of addresses are independent from each other and has an independent <code>index</code> id</li>
<li>Addresses that are created by <code>account.generateAddress()</code> are indicated as <code>internal=false</code> (public)</li>
<li>Internal addresses (<code>internal=true</code>) are called <code>change</code> addresses and are used to send the excess funds to them</li>
<li>The approach is also known as a <em>BIP32 Hierarchical Deterministic wallet (HD Wallet)</em></li>
</ul>
<p><em>Note: You may remember IOTA 1.0 network in which addresses were not reusable. It is no longer true and addresses can be reused multiple times in IOTA 1.5 (Chrysalis) network.</em></p>
<h3 id="4-listen-to-events"><a class="header" href="#4-listen-to-events">4. Listen to events</a></h3>
<p>The <code>Wallet.rs</code> library supports several events for listening. As soon as the given event occurs, a provided callback is triggered.</p>
<p>Below is an example of fetching existing accounts and listening to transaction events coming into the account:</p>
<pre><code class="language-javascript">    const { addEventListener } = require('@iota/wallet')

    const callback = function(err, data) {
        if(err) console.log(&quot;err:&quot;, err)
        console.log(&quot;data:&quot;, data)
    }

    //Adds a new event listener with a callback in the form of (err, data) =&gt; {}. Supported event names:
    addEventListener(&quot;BalanceChange&quot;, callback)

    // Possible Event Types:
    //
    // ErrorThrown
    // BalanceChange
    // NewTransaction
    // ConfirmationStateChange
    // Reattachment
    // Broadcast

</code></pre>
<p>Example output:</p>
<pre><code class="language-bash">data: {
  accountId: 'wallet-account://1666fc60fc95534090728a345cc5a861301428f68a237bea2b5ba0c844988566',
  address: {
    address: 'atoi1q9c6r2ek5w2yz54en78m8dxwl4qmwd7gmh9u0krm45p8txxyhtfry6apvwj',
    balance: 20000000,
    keyIndex: 0,
    internal: false,
    outputs: [ [Object], [Object] ]
  },
  balance: 20000000
}
</code></pre>
<p><code>accountId</code> can then be used to identify the given account via <code>AccountManager.getAccount(accountId)</code>.</p>
<p>For reference, you can read more about events in the <a href="https://wallet-lib.docs.iota.org/libraries/nodejs/api_reference.html#addeventlistenerevent-cb">API reference</a>.</p>
<h3 id="5-check-the-account-balance"><a class="header" href="#5-check-the-account-balance">5. Check the account balance</a></h3>
<p>Get the available account balance across all addresses of the given account:</p>
<pre><code class="language-javascript">    // Always sync before account interactions
    console.log('syncing...')
    const synced = await account.sync()
    console.log('synced!')
    let balance = account.balance().available
    console.log('available balance', balance)
</code></pre>
<h3 id="6-enable-withdrawals"><a class="header" href="#6-enable-withdrawals">6. Enable withdrawals</a></h3>
<p>Sending tokens is performed via the <code>SyncedAccount</code> instance that is a result of the <code>account.sync()</code> function:</p>
<pre><code class="language-javascript">    console.log('syncing...')
    const synced = await account.sync()
    console.log('available balance', account.balance().available)

    const address = 'atoi1qykf7rrdjzhgynfkw6z7360avhaaywf5a4vtyvvk6a06gcv5y7sksu7n5cs'

    // TODO: Check if address is valid.

    const amount = 1000000 // Amount in IOTA: 1000000 == 1 MIOTA

    const node_response = await synced.send(
        address,
        amount
    )

    console.log(&quot;Check your message on https://explorer.iota.org/chrysalis/message/&quot;, node_response.id)
</code></pre>
<p>The full function signature is <code>SyncedAccount.send(address, amount[, options])</code>.</p>
<p>Default options are perfectly fine and get the job done; however, additional options can be provided, such as <code>remainderValueStrategy</code>:</p>
<ul>
<li><code>changeAddress</code>: Send the remainder value to an internal address</li>
<li><code>reuseAddress</code>: Send the remainder value back to its original address</li>
</ul>
<p>The <code>SyncedAccount.send()</code> function returns a <code>wallet message</code> that fully describes the given transaction. The <code>messageId</code> can be used later for checking a confirmation status. Individual messages related to the given account can be obtained via <code>account.listMessages()</code> function.</p>
<p>Please note that when sending tokens, a <a href="guides/dev_guide.html#dust-protection">dust protection</a> mechanism should be considered. </p>
<h1 id="chrysalis-migration"><a class="header" href="#chrysalis-migration">Chrysalis Migration</a></h1>
<p>With the advent of the Chrysalis migration, a number of aspects at IOTA are changing for the better. With easier ways to
manage and secure your experience, IOTA will seamlessly integrate these innovations with no service interruptions.</p>
<p>With Chrysalis, we make a clear-cut from the current IOTA protocol, and start a new with a much better, and more mature
network. The new network will support many new use cases and create a foundation for IOTA’s upcoming Coordicide.</p>
<p>This includes one of the innovations that directly impacts one of the most crucial aspects of your experience: funds.</p>
<p>Because of its complexity, the migration process for the next phase of Chrysalis consists of two phases; we are
currently in phase one where you initiate the migration of your funds in one week and which will then be available on
our new network upon launch.</p>
<p>Do note that migrating is a continuous effort that can be done at any time after the initial migration start date.</p>
<h2 id="token-migration-overview"><a class="header" href="#token-migration-overview">Token Migration Overview</a></h2>
<p>Below is an overview of how the migration will take place for normal token holders:</p>
<ul>
<li>You enter your seed in Firefly.</li>
<li>Firefly creates you a new seed and generates an EdDSA address for the new network.</li>
<li>Firefly sends your funds to a specific migration address (which encapsulates your EdDSA address) on the old network.</li>
<li>Your funds become available on the new network on the EdDSA address Firefly created for you.</li>
<li>Your funds are successfully migrated.</li>
</ul>
<p>Note that:</p>
<ul>
<li>If you migrate before the Chrysalis launch, your funds become available at Chrysalis launch.</li>
<li>If you migrate after the Chrysalis launch, your funds will become available shortly after you migrate (within less
than 5 minutes).</li>
</ul>
<blockquote>
<p>Firefly will initially only be available on desktop operating systems such as: macOS, Linux and Windows and not support
migrations for Ledger devices or using a Ledger device.</p>
</blockquote>
<p>For further information on the migration process, see our <a href="https://blog.iota.org/firefly-token-migration/">blog post</a>.</p>
<p>For a detailed explainer on how the migration process works technically,
see <a href="guides/./migration-mechanism.html">migration-mechanism</a></p>
<h2 id="exchange-token-migration-guide"><a class="header" href="#exchange-token-migration-guide">Exchange Token Migration Guide</a></h2>
<p>To help you successfully transfer your tokens securely to the new Chrysalis (IOTA 1.5) network, we created this guide as
an overview of the migration process and its intricacies.</p>
<p>Following dates are important to be aware of:</p>
<ul>
<li>From 21st to 28th of April, token holders are able to pre-migrate their funds. During this period the network has no
limitations and runs as it would normally. Migrating funds during this period effectively locks them up to become
available immediately on the 28th of April after the Chrysalis Phase 2 release.</li>
<li>On the 28th of April, Chrysalis Phase 2 gets released (with its corresponding node software, libraries and tooling).
After that, the legacy network will only support migration transfers going further (this is accompanied by a legacy
node release). This means that both a legacy (albeit only for migrations), and a new Chrysalis Phase 2 network will
co-exist. We therefore suggest stopping withdrawals and deposits some time before the 28th of April, to ensure that no
funds are being sent from/to the exchange (since any non migration transfers will no longer confirm).</li>
</ul>
<p>There are two ways with which you can migrate your funds from the old legacy to new Chrysalis Phase 2 network:</p>
<ol>
<li>You can either use our Firefly wallet (which allows migrating from either an 81-tryte seed or seed vault file).
(Check out this <a href="https://blog.iota.org/firefly-token-migration/">blog post</a> on how to do this).</li>
<li>Or you can craft a migration bundle yourself which transfers your funds to a special migration address under your
control (programmatic approach).</li>
</ol>
<p>Note that if you migrate your funds after the 28th of April, they will become available on the new network within 5
minutes. If you migrate prior to that, your funds will only become available starting on the 28th of April.</p>
<p>This guide will further only explain how to create a migration bundle, and the rules imposed on it.</p>
<h3 id="migrating-funds-by-issuing-migration-bundles"><a class="header" href="#migrating-funds-by-issuing-migration-bundles">Migrating funds by issuing migration bundles</a></h3>
<p>Note that as mentioned above, there will be a special release for the legacy node software on the 28th of April, which
will only further support migration bundles. In case you're operating a node yourself you must upgrade to that version,
as otherwise you will no longer be synchronized with the network.</p>
<h4 id="migration-bundle"><a class="header" href="#migration-bundle">Migration bundle</a></h4>
<p>With this limited legacy network, only migration bundles will further confirm. A migration bundle is nothing else than a
normal value bundle/transfer which has some additional restrictions. If you craft a bundle which obeys to the following
rules, then it falls under what we define as a migration bundle:</p>
<ul>
<li>It contains exactly one output transaction of which the destination address is a valid migration address and is
positioned as the tail transaction within the bundle (meaning <code>currentIndex</code> 0). <strong>The output transaction value is at
least 1'000'000 tokens (1 Mi).</strong></li>
<li>It does not contain any zero-value transactions which do not hold signature fragments. This means that transactions
other than the tail transaction must always be part of an input.</li>
<li>Input transactions must not use migration addresses.</li>
</ul>
<p>If in doubt whether your bundle is an actual migration bundle, you can use
<a href="https://github.com/iotaledger/iota.go/blob/2618d56d58105dfc2f3b7f1eb3481d9f89a1d6bc/bundle/bundle.go#L335">ValidBundle(bundle, true)</a>
function of our iota.go library to validate this. In case you're not acquainted with Go, you can also contact us on
Discord or Slack in order to get the assurance, that you're crafted bundles are valid migration bundles.</p>
<p>Things to consider:</p>
<ul>
<li>You must not broadcast your own migration bundles unless you're 100% sure that they are indeed valid migration
bundles.</li>
<li>If one of your input transactions spends funds from an already used address (meaning it is subject to key re-use), we
recommend that you use
the <a href="guides/(https://github.com/iotaledger/iota.rs/tree/migration/iota-bundle-miner)">bundle miner tool</a>
to craft a bundle with the most applicable security given the already exposed parts of the given address' private key.</li>
<li>Do not use too many input transactions as this will increase the overall Proof-of-Work time needed for a single
bundle. Rather, split your input addresses over multiple migration bundles.</li>
<li>Your code must include logic to await for the migration bundle's confirmation. If you find that your migration bundle
is not confirming, consider re-attaching it (re-attaching is not the same as re-signing the bundle!).</li>
<li>If you submit a migration bundle for broadcasting via the <code>broadcastTransactions</code> API command and you're using the
updated legacy node software (which you must on/after the 28th of April), then it will additionally check up on
submission whether your submitted bundle really adheres to the rules outlined above as an additional safe guard.</li>
</ul>
<p>For further information about the migration bundles, have a look
at <a href="https://github.com/luca-moser/protocol-rfcs/blob/rfc/wotsicide/text/0035-wotsicide/0035-wotsicide.md#migration-bundle">RFC-0035</a>
.</p>
<p>As an
example, <a href="https://explorer.iota.org/mainnet/bundle/ZRAFFSEPRKDYGGA9DJQBWCXG9CGODUNZUBOWHVFQY9DK9HCHJQTHHSYBQRGZHGXWAPXDTJPPFJ9XFUALW">this bundle</a>
is a valid migration bundle. It spends 1 Mi</p>
<ul>
<li>from:
<code>YVLQWMRUZ9RCQODQZFYDNRVXHERUFPSDVLDRQLHEWGJLRTMEAQNX9OHZJVTONDHMUJQECDCUAR9PUIGAZPAAEHTZXB</code></li>
<li>to:
<code>TRANSFERTBIXPEWWYZZWBWPWJCB9XYMC9AGYH9X9AYAYADVXTYGYB9G9J9PEF9O9KYZXS9D9MANWTZOD9B9HMRQFWZ</code>
where the destination address encodes the target Bech32
address <code>iota1qqhmslysuwfedz2mqtr4ux73pr7uhjmd4tpazqs8pf7qdax44muqgw0fz25</code> respectively the hex Ed25519
address <code>2fb87c90e39396895b02c75e1bd108fdcbcb6daac3d102070a7c06f4d5aef804</code> on which the these funds will be made
available in the new network.</li>
</ul>
<h5 id="migration-address"><a class="header" href="#migration-address">Migration Address</a></h5>
<p>As mentioned above, a migration bundle must have as its single destination/output address a migration address. A
migration address is in essence an EdDSA address (to which you hold the keys on the new network) encoded in a legacy
tryte address. You can create such an address in the following way:</p>
<ul>
<li>Compute the <a href="https://tools.ietf.org/html/rfc7693">BLAKE2b-256</a> hash <code>H</code> of your Ed25519 address <code>A</code> (this address is
the one you control in the new network; note that an Ed25519 address is the Blake2b-256 hash of your Ed25519 public
key).</li>
<li>Append the first 4 bytes of <code>H</code> to <code>A</code>, resulting in 36 bytes.</li>
<li>Convert <code>A</code> to trytes using the <code>b1t6</code> encoding (as described
in <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0015-binary-to-ternary-encoding/0015-binary-to-ternary-encoding.md">RFC-15</a>)
. This results in <code>A</code><sub>tri</sub> consisting of 72 trytes.</li>
<li>Prepend the 8-tryte prefix <code>TRANSFER</code> to <code>A</code><sub>tri</sub>.</li>
<li>Finally, pad <code>A</code><sub>tri</sub> with the single tryte <code>9</code> to get a legacy 81-tryte address.</li>
</ul>
<p>Example:</p>
<ul>
<li>Ed25519 address (32-byte): <code>6f9e8510b88b0ea4fbc684df90ba310540370a0403067b22cef4971fec3e8bb8</code></li>
<li>Migration address including 9-tryte checksum (
90-tryte): <code>TRANSFERCDJWLVPAIXRWNAPXV9WYKVUZWWKXVBE9JBABJ9D9C9F9OEGADYO9CWDAGZHBRWIXLXG9MAJV9RJEOLXSJW</code></li>
</ul>
<p>Since nobody holds keys to such migration addresses, funds are effectively burned and can no longer be used in the
legacy network.</p>
<h1 id="how-the-iota-chrysalis-phase-2-token-migration-works"><a class="header" href="#how-the-iota-chrysalis-phase-2-token-migration-works">How the IOTA Chrysalis Phase 2 Token Migration works</a></h1>
<p>For the transition to Chrysalis Phase 2, the IOTA Foundation had to develop a way for funds to be migrated to this new
network. The reason a migration mechanism needs to exist in the first place, is because the new network no longer
supports WOTS addresses (currently all funds in the legacy network reside on these).</p>
<p>The developed mechanism features following properties:</p>
<ul>
<li>It is trustless, meaning that everyone who's interested can verify that migrated funds are indeed legit and are not
minted out of thin air.</li>
<li>Migrated funds take less than 5 minutes until they become available in the new network.</li>
<li>Migrations can take place any time for the foreseeable future.</li>
</ul>
<p>Before going into the actual developed mechanism, lets see why other mechanisms were not chosen:</p>
<ul>
<li><code>Migrating funds by performing periodic global snapshots on both networks</code>: While this approach certainly would have
been the easiest to do, it would have blocked funds of people between the times of global snapshots. For example, if
we would have taken global snapshots monthly (to carry over funds from burn/migration addresses), token holders would
have been excluded from opportunities arising from the change in token price: i.e., perhaps you wanted to sell your
tokens but were blocked by the fact that the next global snapshot would only be performed in 20 days and so you
couldn't move your tokens to an exchange (which only supports Chrysalis Phase 2 IOTA).</li>
<li><code>Supporting WOTS on Chrysalis Phase 2 (and only allowing to send to non WOTS addresses)</code>: While certainly also a
viable option, we decided to not include support for WOTS as it brings a number of legacy problems we want to get rid
of:
<ul>
<li>WOTS signatures are very large and make up a disproportional amount of data in a transaction (note that our PoW
requirement in Chrysalis Phase 2 is dependent on the size of the message). Additionally, there were no real bounds
on how big such signatures could grow to (even if per default we only supported 3 security levels in our
libraries).</li>
<li>We would have needed to pollute our new Chrysalis Phase 2 models with support for these addresses and signatures,
adding unnecessary complexity to what should be a clean protocol.</li>
<li>Chrysalis Phase 2 nodes would have needed to keep a spent address list to inform wallets that they had vulernable
addresses.</li>
</ul>
</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The developed migration mechanism is built from following components:</p>
<ul>
<li>Chrysalis phase 2 data types (
see <a href="https://github.com/luca-moser/protocol-rfcs/blob/rfc/wotsicide/text/0035-wotsicide/0035-wotsicide.md">the RFC</a>
for details):
<ul>
<li><code>Treasury Output</code>: an object which specifies an amount of tokens held in the treasury.</li>
<li><code>Treasury Input</code>: an object which references a previous <code>Treasury Output</code>.</li>
<li><code>Treasury Transaction</code>: an object which defines a <code>Treasury Input</code> referencing the last <code>Treasury Output</code> and a
new <code>Treasury Output</code> holding the delta of what the <code>Treasury Transaction</code> is spending.</li>
<li><code>Receipt</code>: an object which holds a pointer to a legacy milestone index, a list of funds to mint and
a <code>Treasury Transaction</code>. A <code>Receipt</code> can only be an inner payload of a milestone.</li>
</ul>
</li>
<li>Chrysalis Phase 2 nodes which validate receipts</li>
<li>Legacy nodes which provide a special API command for the above Chrysalis Phase 2 nodes</li>
<li><code>Treasury</code>: this is simply the last <code>Treasury Output</code> in the ledger. There exists only ever one at any point in time.
When the Chrysalis Phase 2 network launches, the <code>Treasury</code> contains the total supply of tokens (2779530283277761) minus the funds which were already migrated during the &quot;7-day-migration-period&quot; prior to the network
launch. This means that all funds which are not migrated from the legacy network, always will reside in the <code>Treasury</code>
.</li>
</ul>
<p>Note, that again, a <code>Receipt</code> can only be contained within a milestone and that valid milestones can only be issued by
the Coordinator, therefore, minting of migrated funds can only happen through milestones and not any other type of
transactions. Likewise, a <code>Treasury Transaction</code> is only valid to be an inner payload of a <code>Receipt</code>.</p>
<h2 id="how-it-actually-works"><a class="header" href="#how-it-actually-works">How it actually works</a></h2>
<ol>
<li>In essence, a <code>Receipt</code> carries the information about funds which were migrated or &quot;burned&quot; to a <code>migration address</code>
on the legacy network. A <code>migration address</code> looks like any other normal address on the legacy network but it
encapsulates actual information, such as:
<ul>
<li>The target Ed25519 address on the Chrysalis Phase 2 network from which the token holder wants their funds to be
accessible from.</li>
<li>A checksum of that Ed25519 address.</li>
<li>A tryte prefix <code>TRANSFER</code>. (these addresses always start with this prefix)</li>
</ul>
</li>
<li>As mentioned above, a <code>Receipt</code> can only be contained in a milestone and therefore the Coordinator on the Chrysalis
Phase 2 network:
<ol>
<li>periodically polls data from a legacy node about what kind of newly confirmed burned/migrated funds there are (
while also performing WOTS signature verification on these and the legacy milestone bundle).</li>
<li>and then produces a milestone with a <code>Receipt</code> containing those funds, where within the <code>Receipt</code>,
a <code>Treasury Transaction</code> is placed which deducts the sum of tokens migrated from the <code>Treasury</code>.</li>
</ol>
</li>
<li>Chrysalis Phase 2 nodes then see receipts when applying milestones and automatically generate outputs for the Ed25519
address as defined in the origin <code>migration address</code> in the legacy network. As an optional step (which is not turned
on by default), every node can be configured to verify whether the funds in the receipt really were migrated in the
old network using a legacy node and whether all funds for a given legacy milestone index were migrated. If this
verification fails, the node will automatically panic as the integrity is no longer correct.</li>
</ol>
<p>This means that:</p>
<ul>
<li>The IOTA Foundation can not mint funds out of thin air, because nodes in the Chrysalis Phase 2 network verify that the
funds were burned in the legacy network.</li>
<li>All migration bundles, respectively transfers to <code>migration addresses</code> which were confirmed by a given legacy
milestone, must be migrated fully to the new network, as otherwise the verification fails.</li>
<li>Node operators are free to choose which legacy nodes they query with their Chrysalis Phase 2 nodes, so the
verification of migrations/receipts is decentralized. For example, a node operator chooses to both operate their own
legacy and Chrysalis Phase 2 nodes.</li>
</ul>
<p>Essentially then via the Firefly wallet, token holders will:</p>
<ol>
<li>Produce migration bundles which send funds to <code>migration addresses</code> controlled by the given owner.</li>
<li>These bundles get confirmed on the legacy network.</li>
<li>The Chrysalis Phase 2 Coordinator picks these confirmed legacy bundles up and generates receipts minting those funds
to the target Ed25519 address.</li>
<li>Verifier nodes verify the receipts and make sure that the funds originate from the legacy network.</li>
</ol>
<h3 id="verifier-node"><a class="header" href="#verifier-node">Verifier node</a></h3>
<p>A verifier node is a Chrysalis Phase 2 node which up on seeing receipts:</p>
<ol>
<li>Queries a legacy node for the confirmation data for the specified milestone in the receipt.</li>
<li>Then performs WOTS signature verification of the legacy milestone bundle and all confirmed bundles.</li>
<li>Additionally it also checks that all confirmed funds on the legacy network for the given legacy milestone, are
indeed minted with a given batch of receipts. (i.e. nothing is left out)</li>
</ol>
<p>See <a href="https://hornet.docs.iota.org/post_installation/run_as_verifier.html">Hornet as a verifier node</a></p>
<h1 id="iota-hub-migration-guide"><a class="header" href="#iota-hub-migration-guide">IOTA Hub migration guide</a></h1>
<blockquote>
<p>This guide will explain how you can switch from IOTA Hub to using wallet.rs or its bindings instead.</p>
</blockquote>
<p>Because of the unique features of IOTA 1.0, it was difficult to manage IOTA transactions with just a library. With the new Chrysalis update, the whole protocol was updated to be more accommodating to industry wide standards and developer friendliness. </p>
<p>IOTA Hub will be deprecated with the Chrysalis upgrade and will not work with the new protocol changes. If you still use Hub, we ask you to utilize our new wallet library (iota.rs or bindings) where you can easily manage IOTA addresses, deposits, and withdrawals for user accounts.</p>
<p>To upgrade from Hub to a Chrysalis implementation you need to:</p>
<ul>
<li>Integrate the Chrysalis network using wallet.rs as mentioned in the Exchange section</li>
<li>Pause withdrawals/deposits</li>
<li>Make sure all balances have been swept and all deposits have been processed</li>
<li>Transfer all IOTA to a generated migration address (instructions to be provided)</li>
<li>Once migrated, transfer the IOTA coins to your hot wallet account on your wallet.rs implementation</li>
</ul>
<h1 id="backup-and-security"><a class="header" href="#backup-and-security">Backup and security</a></h1>
<p>Security Checklist</p>
<ul>
<li>How to backup your account</li>
<li>How to restore from a backup</li>
<li>How to export a user's Stronghold</li>
<li>How to rekey a Stronghold/password rotation</li>
<li>Do's and don'ts</li>
</ul>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
I use Stronghold</li>
<li><input disabled="" type="checkbox"/>
I use a strong password (32 character length, Shannon Entropy ~ 4.0) for encrypting the stronghold</li>
<li><input disabled="" type="checkbox"/>
I rotate the stronghold password on a regular basis</li>
<li><input disabled="" type="checkbox"/>
I create a daily backup of the stronghold.snapshot file</li>
<li><input disabled="" type="checkbox"/>
I keep a secure history of passwords used (for recovery)</li>
<li><input disabled="" type="checkbox"/>
I use a secure password management service that integrates with the server</li>
<li><input disabled="" type="checkbox"/>
I use a linux based server (best memory security)</li>
<li><input disabled="" type="checkbox"/>
My server is isolated behind a DMZ</li>
</ul>
<h2 id="how-to-backup-your-account"><a class="header" href="#how-to-backup-your-account">How to backup your account</a></h2>
<p>A simple copy of the stronghold.snapshot file works as a backup (e.g. a daily cronjob rsync/scp with a datetime suffix for example).</p>
<h2 id="how-to-restore-from-a-backup"><a class="header" href="#how-to-restore-from-a-backup">How to restore from a backup</a></h2>
<p>Simply place a snapshot file in your directory that wallet.rs expects.</p>
<h2 id="how-to-export-a-users-stronghold"><a class="header" href="#how-to-export-a-users-stronghold">How to export a user's stronghold</a></h2>
<p>You can create a new Stronghold snapshot on the fly to allow a user to leave your service and retain their key.</p>
<h2 id="how-to-rekey-a-strongholdpassword-rotation"><a class="header" href="#how-to-rekey-a-strongholdpassword-rotation">How to rekey a Stronghold/password rotation</a></h2>
<p>The procedure for changing a Stronghold password is &quot;simple&quot; in that you read a snapshot into a vault and then write it out with a new encryption password. <a href="https://github.com/iotaledger/wallet.rs/blob/d1b8893d73aae35dfcf7c5c8006e2177988d25d0/src/stronghold.rs#L436-L451">See this code for the source.</a></p>
<p>Please note: for obvious reasons, old snapshot backups will not be &quot;rekeyed&quot;, so you have to track your old passwords. </p>
<h2 id="dos-and-donts"><a class="header" href="#dos-and-donts">Do's and don'ts</a></h2>
<ul>
<li>Don't use SQLite</li>
<li>Don't store passwords and backups on the same device</li>
</ul>
<h1 id="chrysalis-snapshot-validationboostrapping"><a class="header" href="#chrysalis-snapshot-validationboostrapping">Chrysalis Snapshot Validation/Boostrapping</a></h1>
<p>In this guide you will learn how to partake in the global snapshot, respectively genesis snapshot creation for the legacy and Chrysalis Phase 2 IOTA network. The goal is to generate a global snapshot for the legacy network which acts as a cut-off point for when only migration bundles/transactions are allowed and a genesis snapshot for the new network which contains the already burned/migrated funds from the 7-day-migration window.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>A GitHub account and git</li>
<li>A synchronized legacy Hornet node (running version &lt; 0.x.x)
<ul>
<li>The <code>getLedgerState</code> API command must be permitted. Add an entry to  <code>httpAPI.permitRemoteAccess</code> in case this API command is not added yet (restart your node afterwards).</li>
<li>The API port must be accessible</li>
</ul>
</li>
<li>Golang version 1.16.x (https://golang.org/)</li>
</ul>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<blockquote>
<p>Make sure you've Go installed by issuing <code>go version</code> on your command line.</p>
</blockquote>
<ol>
<li><code>git clone https://github.com/iotaledger/chrysalis-tools.git</code></li>
<li><code>cd chrysalis-tools/snapshot/verify</code></li>
<li><code>go build</code> (this should generate a <code>verify</code>/<code>verify.exe</code> binary respectively)</li>
<li><code>./verify -node=&quot;https://your-node-uri&quot; -genesis-snapshot-file-network-id=&quot;&lt;network-id-for-chrysalis-phase-2&gt;&quot;</code> (the network Id is communicated in the validation issue in the <a href="https://github.com/gohornet/hornet">Hornet repository</a>)</li>
<li>The program will now fetch the current ledger state of your defined legacy Hornet node, compute its Blake2b-256 hash and generate the global snapshot for the legacy and genesis snapshot for the new network. Example output:</li>
</ol>
<pre><code>2021/04/20 11:10:56 querying legacy node for info...
2021/04/20 11:10:57 legacy node state: lsmi/lsm 3636697/3636697
2021/04/20 11:10:57 fetching ledger state at 3636697, this might take a while...go grab a coffee...
2021/04/20 11:11:01 total ledger entries: 430699
2021/04/20 11:11:02 ledger state integrity hash: 34ecf812f0547a685f6a826b518d9bad0ed1bcaab3fb8ea4c5e06106c5b5e01f
2021/04/20 11:11:02 migration: addrs 1, tokens total 1629957
2021/04/20 11:11:02 eligible for migration: addrs 317469, tokens total 2779523376246858
</code></pre>
<ol start="6">
<li>Generate the sha256 hashes of the generated <code>global_snapshot.csv</code> and <code>genesis_snapshot.bin</code>: <code>sha256sum global_snapshot.csv genesis_snapshot.bin</code>; Example output:</li>
</ol>
<pre><code>$ sha256sum global_snapshot.csv genesis_snapshot.bin 
f19a0976cc51b22d91018754a6cb41381fd737eb11b790a6db12a6d04a2bcddd  global_snapshot.csv
ebc6ce9d8cd6f00dd6ff42dc72335367bc7b181ef1f2f76a63d6c2b75e74ff24  genesis_snapshot.bin

</code></pre>
<ol start="8">
<li>Copy the entire program output and the sha256 hashes to the corresponding issue on the <a href="https://github.com/gohornet/hornet">Hornet repository</a>.</li>
</ol>
<h2 id="bootstrapping-the-legacy-hornet-node-from-the-global-snapshot"><a class="header" href="#bootstrapping-the-legacy-hornet-node-from-the-global-snapshot">Bootstrapping the legacy Hornet node from the global snapshot</a></h2>
<blockquote>
<p>Loading the global snapshot ensures that your legacy Hornet node adds the genesis transaction (999...) as a solid entry point: this is important as the Coordinator will issue the next milestone after the global snapshot index on top of it. Your node will <strong>not</strong> lose the data it already has.</p>
</blockquote>
<ol>
<li>Await for confirmation that the global snapshot was taken successfully by looking into the validation issue on the <a href="https://github.com/gohornet/hornet">Hornet repository</a> or Discord.</li>
<li>Stop your legacy Hornet node and download the binary or docker image of the Hornet build which only supports migration-bundles. With this &quot;migration-bundles-only&quot; version, your Hornet node will also no longer peer to nodes which do not run the same version.</li>
<li>Let <code>snapshots.global.path</code> point to the global snapshot file (i.e <code>global_snapshot.csv</code>).</li>
<li>Under <code>snapshots.global.index</code> define the index of the milestone at which the global snapshot was taken. (this should correspond to what <code>legacy node state</code> was from the program output, i.e. <code>3636697</code> from the example output above).</li>
<li>Change <code>snapshots.loadType</code> to <code>&quot;global&quot;</code> (note the quotes as the value is a string).</li>
<li>Restart your legacy Hornet <strong>with the additional <code>--forceGlobalSnapshot</code> flag</strong> (this will instruct your Hornet node to load the global snapshot despite the fact that it already has a database).</li>
</ol>
<h1 id="testnet"><a class="header" href="#testnet">Testnet</a></h1>
<p>IOTA 1.5 (also known as Chrysalis) is IOTA's intermediate stage before Coordicide is complete. You can read more about the strategy for releasing Chrysalis <a href="https://blog.iota.org/release-strategy-for-chrysalis-iota-1-5-4ea8741ea3a1/">here</a>.</p>
<h2 id="infrastructure-1"><a class="header" href="#infrastructure-1">Infrastructure</a></h2>
<p>Nodes deployed to the testnet can be queried using a load balancer at:</p>
<ul>
<li>api.lb-0.testnet.chrysalis2.com</li>
</ul>
<p>We recommend using the load balancer for most scenarios.</p>
<p>Single node endpoints that expose native MQTT, in case you need them, are:</p>
<ul>
<li>api.hornet-0.testnet.chrysalis2.com</li>
<li>api.hornet-1.testnet.chrysalis2.com</li>
<li>api.hornet-2.testnet.chrysalis2.com</li>
<li>api.hornet-3.testnet.chrysalis2.com</li>
</ul>
<p>The Node API is integrated according to the <a href="https://editor.swagger.io/?url=https://raw.githubusercontent.com/rufsam/protocol-rfcs/master/text/0026-rest-api/rest-api.yaml">following specification</a>.</p>
<h2 id="developer-tools-1"><a class="header" href="#developer-tools-1">Developer tools</a></h2>
<ul>
<li><a href="https://explorer.iota.org/chrysalis">Explorer</a></li>
<li><a href="https://faucet.testnet.chrysalis2.com/">Online Faucet</a></li>
<li><a href="https://github.com/iotaledger/cli-wallet">cli-wallet</a></li>
<li><a href="https://github.com/iotaledger/chrysalis-faucet">chrysalis-faucet Code (nodejs + svelte)</a></li>
</ul>
<h1 id="iota-protocol-rfcs"><a class="header" href="#iota-protocol-rfcs">IOTA Protocol RFCs</a></h1>
<p>Changes to the IOTA protocol have to go through a proposal process first, where a proposal is posted as a &quot;Request for comment&quot; (RFC). The Chrysalis protocol changes are described in full detail in these RFC's which can be found below:</p>
<ul>
<li><a href="https://github.com/iotaledger/protocol-rfcs/pulls">Git Repo</a></li>
</ul>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h3 id="official-support"><a class="header" href="#official-support"><strong>Official support</strong></a></h3>
<hr />
<h4 id="iota-explorer"><a class="header" href="#iota-explorer"><strong>IOTA Explorer</strong></a></h4>
<p><a href="https://explorer.iota.org/chrysalis">Link</a></p>
<p>Official Tangle explorer with a lot of tools to browse through the Tangle.</p>
<hr />
<h4 id="discord"><a class="header" href="#discord"><strong>Discord</strong></a></h4>
<p><a href="https://discord.iota.org">Link</a></p>
<p>The official Discord server where community members and the IOTA Foundation discuss projects and related subjects.</p>
<hr />
<h4 id="iota-stackexchange"><a class="header" href="#iota-stackexchange"><strong>IOTA StackExchange</strong></a></h4>
<p><a href="https://iota.stackexchange.com">Link</a></p>
<p>The official forum where you can ask or answer technical questions about IOTA.</p>
<hr />
<h3 id="community-support"><a class="header" href="#community-support"><strong>Community support</strong></a></h3>
<hr />
<h4 id="thetangleorg---iota-explorer"><a class="header" href="#thetangleorg---iota-explorer">TheTangle.org - IOTA Explorer</a></h4>
<p><a href="https://thetangle.org">Link</a></p>
<p>A community tool for searching transactions in the Tangle.</p>
<hr />
<h4 id="tangleexplorer---iota-explorer"><a class="header" href="#tangleexplorer---iota-explorer">TangleExplorer - IOTA Explorer</a></h4>
<p><a href="https://tanglexplorer.com/mainnet">Link</a></p>
<p>An community tool for searching transactions in the Tangle.</p>
<hr />
<h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="which-libraries-are-available-for-chrysalis"><a class="header" href="#which-libraries-are-available-for-chrysalis">Which libraries are available for Chrysalis?</a></h2>
<p>At this time, there are a handful of libraries available for Chrysalis which are outlined below:</p>
<p>A low level library called iota.rs which is a client library meant to connect to a IOTA node for core interactions with the Tangle. It is written in Rust and there are currently two bindings for Node.js and Python allowing you to use this library from those languages as well. </p>
<p>For value transactions, there is the wallet.rs library which provides a stateful way to manage IOTA coins for one or multiple accounts. It is also written in Rust and there are currently two bindings for Node.js and Python. </p>
<p>Additionally, there is also a native C (<a href="https://github.com/iotaledger/iota.c">iota.c</a>) and an alternative, native javascript (<a href="https://github.com/iotaledger/iota.js/tree/chrysalis">iota.js</a>) client library. </p>
<h2 id="what-is-dust-protection-and-how-does-it-work"><a class="header" href="#what-is-dust-protection-and-how-does-it-work">What is Dust protection and how does it work?</a></h2>
<p>Since IOTA is feeless and has the ability to send microtransactions, attackers could use this to spam the network with very low value transactions, which we call dust. To avoid this we only allow microtransaction below 1Mi of IOTA tokens to another address if you already have at least 1Mi on that address.</p>
<p>You can read more about Dust Protection <a href="https://github.com/iotaledger/protocol-rfcs/pull/32">in the RFC here</a>.</p>
<h2 id="whats-happening-with-coordicide"><a class="header" href="#whats-happening-with-coordicide">What's happening with Coordicide?</a></h2>
<p>This release called Chrysalis still depends on the Coordinator/Compass to run and issue milestones. The next big release after Chrysalis will be Coordicide where we get rid of that dependency. This release is currently in a research/testing phase and will be the main priority after the Chrysalis release.</p>
<h2 id="when-is-a-transaction-on-the-network-considered-finalirreversible"><a class="header" href="#when-is-a-transaction-on-the-network-considered-finalirreversible">When is a transaction on the network considered final/irreversible?</a></h2>
<p>Confirmation times on the new network are on average around 10 seconds. Once a transaction is set to confirm it’s final transaction, you don’t have block confirmations like with blockchain.</p>
<h2 id="hornet-or-bee-which-node-software-should-i-use"><a class="header" href="#hornet-or-bee-which-node-software-should-i-use">Hornet or Bee? Which node software should I use?</a></h2>
<p>You can pick either Bee (Rust based) or Hornet (Go based). We currently recommend Hornet since it’s the more complete version of the node software, Bee is still missing some optional features you might wish to use.</p>
<h2 id="what-are-spent-addresses-and-why-are-they-dangerous"><a class="header" href="#what-are-spent-addresses-and-why-are-they-dangerous">What are spent addresses and why are they dangerous?</a></h2>
<ul>
<li>In the IOTA 1.0 network, IOTA used Winternitz One Time Signatures (W-OTS) - think of these as, more or less, an authenticator and validator for a transaction. These keys and signatures are highly secure against malicious attacks for signing transactions. But, on the downside, by signing a transaction, W-OTS reveals parts of a private key for the specific address tokens are being spent from. </li>
<li>With W-OTS every time a signature is signed to spend tokens from a particular address, any remaining tokens need to be moved onto a new address to prevent malicious actors from brute-forcing (trial-and-error guessing) the remaining parts of the private key for the address. That’s the main reason why this signature scheme is considered to be a “one-time signature”. </li>
<li>So after the Chrysalis update, we are using the Ed25519, based on the EdDSA, scheme instead of W-OTS. The advantage is that the new scheme addresses all of the issues that W-OTS originally had, where Ed25519 verifies both single-signature and batch verification (taking care of the left over/remaining tokens) very quickly as well as faster key generation and smaller signatures (very secure). </li>
</ul>
<h2 id="what-is-bundle-mining"><a class="header" href="#what-is-bundle-mining">What is bundle mining?</a></h2>
<ul>
<li>If you have spent addresses, it means you accidentally received funds to an address that was already spent from and these funds are not safe to send again due to W-OTS. </li>
<li>To secure your spent addresses during the migration, Firefly will try to find a new bundle that reveals the least amount of additional private key parts compared to previous signs.</li>
<li>This process will take 10 minutes per spent address and upon completion you will be presented with a risk calculation (very high, high, medium, low, very low). It is recommended that you repeats the process if it returns a bundle with medium risk or higher, particularly for significant sums of IOTA. You have the option to select which addresses you want to mine for and again which you want to rerun the process for.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
